"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createDeferredStrategy = exports.syncStrategy = exports.standardStrategy = exports.asyncStrategy = exports.blazingStrategy = exports.createProgressiveStrategy = void 0;
const utils_1 = require("./utils");
const load_1 = require("./load");
const loader_1 = require("./loader");
const aggregate_1 = require("./aggregate");
function runAll(createApi, existingPilets, additionalPilets, hooks) {
    if (!Array.isArray(existingPilets)) {
        return Promise.reject(`The existing pilets must be passed as an array.`);
    }
    if (!(0, utils_1.checkCreateApi)(createApi)) {
        return Promise.resolve([]);
    }
    try {
        for (const existing of existingPilets) {
            const { name } = existing;
            const [newPilet] = additionalPilets.filter((pilet) => pilet.name === name);
            if (newPilet) {
                additionalPilets.splice(additionalPilets.indexOf(newPilet), 1);
            }
        }
        const pilets = [...existingPilets, ...additionalPilets];
        return (0, aggregate_1.runPilets)(createApi, pilets, hooks);
    }
    catch (err) {
        return Promise.reject(err);
    }
}
/**
 * This strategy is dependent on the async parameter. If false it will start rendering when
 * everything has been received, otherwise it will start rendering when the metadata has been
 * received. In any case it will evaluate pilets as fast as possible.
 * @param async Uses the asynchronous mode.
 */
function createProgressiveStrategy(async) {
    return (options, cb) => {
        const { fetchPilets, dependencies = {}, createApi, config, pilets = [], loadPilet = (0, loader_1.getDefaultLoader)(config), loaders, hooks, } = options;
        const loadingAll = (0, load_1.loadMetadata)(fetchPilets);
        const loadSingle = (0, loader_1.extendLoader)(loadPilet, loaders);
        return (0, utils_1.registerDependencies)(dependencies).then(() => {
            if (!(0, utils_1.checkCreateApi)(createApi)) {
                cb(undefined, []);
                return Promise.resolve();
            }
            return (0, aggregate_1.runPilets)(createApi, pilets, hooks).then((integratedPilets) => {
                if (async && integratedPilets.length > 0) {
                    cb(undefined, [...integratedPilets]);
                }
                const followUp = loadingAll.then((metadata) => {
                    const promises = metadata.map((m) => loadSingle(m).then((app) => {
                        const available = pilets.filter((m) => m.name === app.name).length === 0;
                        if (available) {
                            return (0, aggregate_1.runPilet)(createApi, app, hooks).then((additionalPilet) => {
                                integratedPilets.push(additionalPilet);
                                if (async) {
                                    cb(undefined, [...integratedPilets]);
                                }
                            });
                        }
                    }));
                    return Promise.all(promises).then(() => {
                        if (!async) {
                            cb(undefined, integratedPilets);
                        }
                    });
                });
                return async ? loadingAll.then() : followUp.then();
            });
        });
    };
}
exports.createProgressiveStrategy = createProgressiveStrategy;
/**
 * This strategy starts rendering when the pilets metadata has been received.
 * Evaluates the pilets once available without waiting for all pilets to be
 * available.
 */
function blazingStrategy(options, cb) {
    const strategy = createProgressiveStrategy(true);
    return strategy(options, cb);
}
exports.blazingStrategy = blazingStrategy;
/**
 * The async strategy picked when no strategy is declared and async is set to
 * true. Directly renders, but waits for all pilets to be available before
 * evaluating them.
 */
function asyncStrategy(options, cb) {
    standardStrategy(options, cb);
    return (0, utils_1.promisify)();
}
exports.asyncStrategy = asyncStrategy;
/**
 * The standard strategy that is used if no strategy is declared and async is
 * false. Loads and evaluates all pilets before rendering.
 */
function standardStrategy(options, cb) {
    const { fetchPilets, dependencies = {}, createApi, config, pilets = [], loadPilet = (0, loader_1.getDefaultLoader)(config), loaders, hooks, } = options;
    const loadSingle = (0, loader_1.extendLoader)(loadPilet, loaders);
    return (0, utils_1.registerDependencies)(dependencies)
        .then(() => (0, load_1.loadPilets)(fetchPilets, loadSingle))
        .then((additionalPilets) => runAll(createApi, pilets, additionalPilets, hooks))
        .then((integratedPilets) => cb(undefined, integratedPilets))
        .catch((error) => cb(error, []));
}
exports.standardStrategy = standardStrategy;
/**
 * The strategy that could be used for special purposes, e.g., SSR or specific
 * builds of the Piral instance. This strategy ignores the fetcher and only
 * considers the already given pilets.
 */
function syncStrategy(options, cb) {
    const { createApi, hooks, dependencies = {}, pilets = [] } = options;
    return (0, utils_1.registerDependencies)(dependencies).then(() => runAll(createApi, pilets, [], hooks).then((integratedPilets) => cb(undefined, integratedPilets), (err) => cb(err, [])));
}
exports.syncStrategy = syncStrategy;
/**
 * Creates a strategy that deferres the actual loading until a trigger promise resolves.
 * The loading spinner is not shown during this time and pilets are supposed to appear directly.
 * @param trigger The trigger resolving when the strategy should be applied.
 * @param strategy The strategy to apply. Falls back to the standard strategy.
 * @returns A pilet loading strategy.
 */
function createDeferredStrategy(trigger, strategy = standardStrategy) {
    return (options, cb) => {
        cb(undefined, []);
        trigger.then(() => strategy(options, cb));
        return (0, utils_1.promisify)();
    };
}
exports.createDeferredStrategy = createDeferredStrategy;
//# sourceMappingURL=strategies.js.map