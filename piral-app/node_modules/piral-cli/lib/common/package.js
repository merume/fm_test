"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.retrievePiletData = exports.findPiletRoot = exports.combinePiletExternals = exports.checkAppShellPackage = exports.patchPiletPackage = exports.isValidDependency = exports.validateSharedDependencies = exports.retrievePiletsInfo = exports.retrieveExternals = exports.flattenExternals = exports.findPackageVersion = exports.findDependencyVersion = exports.retrievePiralRoot = exports.getPiletsInfo = exports.copyPiralFiles = exports.copyScaffoldingFiles = exports.getFileStats = exports.getPiralPackage = exports.patchPiralPackage = exports.readPiralPackage = exports.findPiralInstances = exports.findPiralInstance = exports.getPiralPath = void 0;
const path_1 = require("path");
const log_1 = require("./log");
const info_1 = require("./info");
const archive_1 = require("./archive");
const enums_1 = require("./enums");
const compatibility_1 = require("./compatibility");
const merge_1 = require("./merge");
const utils_1 = require("./utils");
const importmap_1 = require("./importmap");
const io_1 = require("./io");
const io_2 = require("./io");
const npm_1 = require("./npm");
const npm_2 = require("./npm");
const external_1 = require("../external");
const language_1 = require("./language");
const language_2 = require("./language");
const constants_1 = require("./constants");
const constants_2 = require("./constants");
function appendBundler(devDependencies, bundler, proposedVersion) {
    return __awaiter(this, void 0, void 0, function* () {
        if (bundler && bundler !== 'none') {
            if (isValidDependency(bundler)) {
                const sep = bundler.indexOf('@', 1);
                const hasVersion = sep !== -1;
                const proposedName = bundler.substring(0, hasVersion ? sep : bundler.length);
                const givenVersion = hasVersion ? bundler.substring(sep + 1) : proposedVersion;
                const name = constants_1.bundlerNames.includes(proposedName) ? `piral-cli-${bundler}` : proposedName;
                const versions = new Set([
                    givenVersion,
                    givenVersion.includes('-beta.') && 'next',
                    givenVersion.includes('-alpha.') && 'canary',
                    givenVersion.includes('.') && givenVersion.split('.').slice(0, 2).join('.'),
                    'latest',
                ]);
                for (const version of versions) {
                    if (version) {
                        const isAvailable = yield (0, npm_2.findSpecificVersion)(name, version);
                        // only if something was returned we know that the version exists; so we can take it.
                        if (isAvailable) {
                            devDependencies[name] = version;
                            return;
                        }
                    }
                }
                (0, log_1.log)('generalWarning_0001', `Could not find a valid version for the provided bundler "${bundler}".'`);
            }
            else {
                //Error case - print warning and ignore
                (0, log_1.log)('generalWarning_0001', `The provided bundler name "${bundler}" does not refer to a valid package name.'`);
            }
        }
    });
}
function getDependencyVersion(name, devDependencies, allDependencies) {
    const version = devDependencies[name];
    const selected = typeof version === 'string' ? version : version === true ? allDependencies[name] : undefined;
    if (!selected) {
        (0, log_1.log)('cannotResolveVersion_0052', name);
    }
    return selected || 'latest';
}
const globPatternStartIndicators = ['*', '?', '[', '!(', '?(', '+(', '@('];
function getMatchingFiles(source, target, file) {
    return __awaiter(this, void 0, void 0, function* () {
        const { from, to, deep = true } = typeof file === 'string' ? { from: file, to: file, deep: true } : file;
        const sourcePath = (0, path_1.resolve)(source, from);
        const targetPath = (0, path_1.resolve)(target, to);
        const isDirectory = yield (0, io_1.checkIsDirectory)(sourcePath);
        if (isDirectory) {
            (0, log_1.log)('generalDebug_0003', `Matching in directory "${sourcePath}".`);
            const pattern = deep ? '**/*' : '*';
            const files = yield (0, io_1.matchFiles)(sourcePath, pattern);
            return files.map((file) => ({
                sourcePath: file,
                targetPath: (0, path_1.resolve)(targetPath, (0, path_1.relative)(sourcePath, file)),
            }));
        }
        else if (globPatternStartIndicators.some((m) => from.indexOf(m) !== -1)) {
            (0, log_1.log)('generalDebug_0003', `Matching using glob "${sourcePath}".`);
            const files = yield (0, io_1.matchFiles)(source, from);
            const parts = sourcePath.split('/');
            for (let i = 0; i < parts.length; i++) {
                const part = parts[i];
                if (globPatternStartIndicators.some((m) => part.indexOf(m) !== -1)) {
                    parts.splice(i, parts.length - i);
                    break;
                }
            }
            const relRoot = parts.join('/');
            const tarRoot = (0, path_1.resolve)(target, to);
            return files.map((file) => ({
                sourcePath: file,
                targetPath: (0, path_1.resolve)(tarRoot, (0, path_1.relative)(relRoot, file)),
            }));
        }
        (0, log_1.log)('generalDebug_0003', `Assume direct path source "${sourcePath}".`);
        return [
            {
                sourcePath,
                targetPath,
            },
        ];
    });
}
function getPiralPath(root, name) {
    const path = (0, npm_2.findPackageRoot)(name, root);
    if (!path) {
        (0, log_1.fail)('invalidPiralReference_0043');
    }
    return (0, path_1.dirname)(path);
}
exports.getPiralPath = getPiralPath;
function findPiralInstance(proposedApp, baseDir, port) {
    return __awaiter(this, void 0, void 0, function* () {
        const path = (0, npm_2.findPackageRoot)(proposedApp, baseDir);
        if (path) {
            (0, log_1.log)('generalDebug_0003', `Following the app package in "${path}" ...`);
            const root = (0, path_1.dirname)(path);
            const appPackage = yield (0, io_2.readJson)(root, (0, path_1.basename)(path));
            const relPath = appPackage && appPackage.app;
            appPackage.app = relPath && (0, path_1.resolve)(root, relPath);
            appPackage.root = root;
            appPackage.port = port;
            return appPackage;
        }
        (0, log_1.fail)('appInstanceNotFound_0010', proposedApp);
    });
}
exports.findPiralInstance = findPiralInstance;
function findPiralInstances(proposedApps, piletPackage, piletDefinition, baseDir) {
    var _a;
    return __awaiter(this, void 0, void 0, function* () {
        if (proposedApps) {
            // do nothing
        }
        else if (piletDefinition) {
            const availableApps = Object.keys(piletDefinition.piralInstances || {});
            proposedApps = availableApps.filter((m) => piletDefinition.piralInstances[m].selected);
            if (proposedApps.length === 0) {
                proposedApps = availableApps.slice(0, 1);
            }
        }
        else {
            proposedApps = [(_a = piletPackage.piral) === null || _a === void 0 ? void 0 : _a.name].filter(Boolean);
        }
        if (proposedApps.length > 0) {
            return Promise.all(proposedApps.map((proposedApp) => { var _a, _b, _c; return findPiralInstance(proposedApp, baseDir, (_c = (_b = (_a = piletDefinition === null || piletDefinition === void 0 ? void 0 : piletDefinition.piralInstances) === null || _a === void 0 ? void 0 : _a[proposedApp]) === null || _b === void 0 ? void 0 : _b.port) !== null && _c !== void 0 ? _c : 0); }));
        }
        return [];
    });
}
exports.findPiralInstances = findPiralInstances;
function readPiralPackage(root, name) {
    (0, log_1.log)('generalDebug_0003', `Reading the piral package in "${root}" ...`);
    const path = getPiralPath(root, name);
    return (0, io_2.readJson)(path, 'package.json');
}
exports.readPiralPackage = readPiralPackage;
function patchPiralPackage(root, app, data, version, bundler) {
    return __awaiter(this, void 0, void 0, function* () {
        (0, log_1.log)('generalDebug_0003', `Patching the package.json in "${root}" ...`);
        const pkg = yield getPiralPackage(app, data, version, bundler);
        yield (0, io_2.updateExistingJson)(root, 'package.json', pkg);
        (0, log_1.log)('generalDebug_0003', `Succesfully patched the package.json.`);
        yield (0, io_2.updateExistingJson)(root, 'piral.json', {
            $schema: constants_2.piralJsonSchemaUrl,
            pilets: getPiletsInfo({}),
        });
        (0, log_1.log)('generalDebug_0003', `Succesfully patched the pilet.json.`);
    });
}
exports.patchPiralPackage = patchPiralPackage;
function getPiralPackage(app, data, version, bundler) {
    return __awaiter(this, void 0, void 0, function* () {
        const framework = data.packageName;
        const devDependencies = Object.assign(Object.assign({}, (0, language_1.getDevDependencies)(data.language, (0, language_2.getDevDependencyPackages)(framework, data.reactVersion, data.reactRouterVersion))), { 'piral-cli': `${version}` });
        const dependencies = Object.assign(Object.assign({}, (0, language_2.getFrameworkDependencies)(framework, version)), (0, language_1.getDependencies)(data.language, (0, language_1.getDependencyPackages)(framework, data.reactVersion, data.reactRouterVersion)));
        yield appendBundler(devDependencies, bundler, version);
        return {
            app,
            scripts: {
                start: 'piral debug',
                build: 'piral build',
                postinstall: 'piral declaration',
            },
            types: 'dist/index.d.ts',
            importmap: {
                imports: {},
                inherit: [
                    'piral-base',
                    framework !== 'piral-base' && 'piral-core',
                    framework === 'piral' && 'piral',
                    framework === 'piral-native' && 'piral-native', // this we also only take if we selected piral-native
                ].filter(Boolean),
            },
            dependencies,
            devDependencies,
        };
    });
}
exports.getPiralPackage = getPiralPackage;
function getAvailableFiles(root, name, dirName, fileMap) {
    return __awaiter(this, void 0, void 0, function* () {
        const source = getPiralPath(root, name);
        const tgz = `${dirName}.tar`;
        (0, log_1.log)('generalDebug_0003', `Checking if "${tgz}" exists in "${source}" ...`);
        const exists = yield (0, io_2.checkExists)((0, path_1.resolve)(source, tgz));
        if (exists) {
            yield (0, archive_1.unpackTarball)(source, tgz);
        }
        (0, log_1.log)('generalDebug_0003', `Get matching files from "${source}".`);
        const base = (0, path_1.resolve)(source, dirName);
        const files = yield (0, io_1.matchFiles)(base, '**/*');
        return files.map((file) => ({
            sourcePath: file,
            targetPath: (0, path_1.resolve)(root, (0, path_1.relative)(base, file)),
        }));
    });
}
function getFileStats(root, name, fileMap = []) {
    return __awaiter(this, void 0, void 0, function* () {
        const files = yield getAvailableFiles(root, name, constants_1.filesTar, fileMap);
        return yield Promise.all(files.map((file) => __awaiter(this, void 0, void 0, function* () {
            const { sourcePath, targetPath } = file;
            const sourceHash = yield (0, io_1.getHash)(sourcePath);
            (0, log_1.log)('generalDebug_0003', `Obtained hash from "${sourcePath}": ${sourceHash}`);
            const targetHash = yield (0, io_1.getHash)(targetPath);
            (0, log_1.log)('generalDebug_0003', `Obtained hash from "${targetPath}": ${targetHash}`);
            return {
                path: targetPath,
                hash: targetHash,
                changed: sourceHash !== targetHash,
            };
        })));
    });
}
exports.getFileStats = getFileStats;
function copyFiles(subfiles, forceOverwrite, originalFiles, variables) {
    return __awaiter(this, void 0, void 0, function* () {
        for (const subfile of subfiles) {
            const { sourcePath, targetPath } = subfile;
            const exists = yield (0, io_2.checkExists)(sourcePath);
            if (exists) {
                const overwrite = originalFiles.some((m) => m.path === targetPath && !m.changed);
                const force = overwrite ? enums_1.ForceOverwrite.yes : forceOverwrite;
                yield (0, io_2.copy)(sourcePath, targetPath, force);
            }
            else {
                (0, log_1.fail)('cannotFindFile_0046', sourcePath);
            }
        }
    });
}
function copyScaffoldingFiles(source, target, files, piralInfo, variables) {
    return __awaiter(this, void 0, void 0, function* () {
        (0, log_1.log)('generalDebug_0003', `Copying the scaffolding files ...`);
        const allFiles = [];
        for (const file of files) {
            const subfiles = yield getMatchingFiles(source, target, file);
            allFiles.push(...subfiles);
        }
        if (piralInfo) {
            yield extendPackageOverridesFromTemplateFragment(target, piralInfo, allFiles);
        }
        yield copyFiles(allFiles, enums_1.ForceOverwrite.yes, [], variables);
    });
}
exports.copyScaffoldingFiles = copyScaffoldingFiles;
function extendPackageOverridesFromTemplateFragment(root, piralInfo, files) {
    return __awaiter(this, void 0, void 0, function* () {
        const packageTarget = (0, path_1.resolve)(root, 'package.json');
        for (let i = files.length; i--;) {
            const file = files[i];
            if (file.targetPath === packageTarget) {
                const fragment = yield (0, io_2.readJson)((0, path_1.dirname)(file.sourcePath), (0, path_1.basename)(file.sourcePath));
                files.splice(i, 1);
                if (!piralInfo.pilets) {
                    piralInfo.pilets = {};
                }
                if (!piralInfo.pilets.packageOverrides) {
                    piralInfo.pilets.packageOverrides = {};
                }
                piralInfo.pilets.packageOverrides = Object.assign(Object.assign({}, piralInfo.pilets.packageOverrides), fragment);
            }
        }
    });
}
function isTemplateFileLocation(item) {
    return typeof item === 'object';
}
function tryFindPackageVersion(packageName) {
    try {
        const { version } = require(`${packageName}/package.json`);
        return version;
    }
    catch (_a) {
        return undefined;
    }
}
function copyPiralFiles(root, name, piralInfo, forceOverwrite, variables, originalFiles) {
    return __awaiter(this, void 0, void 0, function* () {
        (0, log_1.log)('generalDebug_0003', `Copying the Piral files ...`);
        const { files: _files } = getPiletsInfo(piralInfo);
        const fileMap = _files.filter(isTemplateFileLocation);
        const files = yield getAvailableFiles(root, name, constants_1.filesTar, fileMap);
        if (originalFiles === undefined) {
            const initialFiles = yield getAvailableFiles(root, name, constants_1.filesOnceTar, fileMap);
            files.push(...initialFiles);
            originalFiles = [];
        }
        yield extendPackageOverridesFromTemplateFragment(root, piralInfo, files);
        yield copyFiles(files, forceOverwrite, originalFiles, variables);
    });
}
exports.copyPiralFiles = copyPiralFiles;
function getPiletsInfo(piralInfo) {
    const { files = [], scripts = {}, template = 'default', validators = {}, devDependencies = {}, preScaffold = '', postScaffold = '', preUpgrade = '', postUpgrade = '', packageOverrides = {}, } = piralInfo.pilets || {};
    return {
        files,
        scripts,
        template,
        validators,
        devDependencies,
        preScaffold,
        postScaffold,
        preUpgrade,
        postUpgrade,
        packageOverrides,
    };
}
exports.getPiletsInfo = getPiletsInfo;
function retrievePiralRoot(baseDir, entry) {
    return __awaiter(this, void 0, void 0, function* () {
        const rootDir = (0, path_1.join)(baseDir, entry);
        (0, log_1.log)('generalDebug_0003', `Retrieving Piral root from "${rootDir}" ...`);
        if (!constants_1.declarationEntryExtensions.includes((0, path_1.extname)(rootDir).toLowerCase())) {
            const packageName = (0, path_1.basename)(rootDir) === 'package.json' ? rootDir : (0, path_1.join)(rootDir, 'package.json');
            (0, log_1.log)('generalDebug_0003', `Trying to get entry point from "${packageName}".`);
            const exists = yield (0, io_2.checkExists)(packageName);
            if (!exists) {
                (0, log_1.fail)('entryPointMissing_0070', rootDir);
            }
            const { app } = require(packageName);
            if (!app) {
                (0, log_1.fail)('entryPointMissing_0071');
            }
            (0, log_1.log)('generalDebug_0003', `Found app entry point in "${app}".`);
            return (0, path_1.join)((0, path_1.dirname)(packageName), app);
        }
        (0, log_1.log)('generalDebug_0003', `Found app entry point in "${rootDir}".`);
        return rootDir;
    });
}
exports.retrievePiralRoot = retrievePiralRoot;
function checkArrayOrUndefined(obj, key) {
    const items = obj[key];
    if (Array.isArray(items)) {
        return items;
    }
    else if (items !== undefined) {
        (0, log_1.log)('expectedArray_0072', key, typeof items);
    }
    return undefined;
}
function findDependencyVersion(pckg, rootPath, dependency) {
    var _a;
    return __awaiter(this, void 0, void 0, function* () {
        const { devDependencies = {}, dependencies = {} } = pckg;
        const packageName = dependency.name;
        const desiredVersion = (_a = dependencies[packageName]) !== null && _a !== void 0 ? _a : devDependencies[packageName];
        const [parent] = dependency.parents || [];
        if (desiredVersion) {
            if ((0, npm_1.isNpmPackage)(desiredVersion)) {
                return desiredVersion;
            }
            else if ((0, npm_1.isGitPackage)(desiredVersion)) {
                return (0, npm_1.makeGitUrl)(desiredVersion);
            }
            else if ((0, npm_1.isLocalPackage)(rootPath, desiredVersion)) {
                return (0, npm_1.makeFilePath)(rootPath, desiredVersion);
            }
        }
        if (parent) {
            // in case the dependency came from another package (= parent)
            // we should start the lookup in its directory (pnpm issue)
            const parentPath = (0, npm_1.tryResolvePackage)(parent, rootPath);
            if (parentPath) {
                rootPath = (0, path_1.dirname)(parentPath);
            }
        }
        const version = yield findPackageVersion(rootPath, packageName);
        if (dependency.alias) {
            return (0, npm_2.makeNpmAlias)(dependency.alias, version);
        }
        return version;
    });
}
exports.findDependencyVersion = findDependencyVersion;
function findPackageVersion(rootPath, packageName) {
    return __awaiter(this, void 0, void 0, function* () {
        const packages = Array.isArray(packageName) ? packageName : [packageName];
        for (const pckg of packages) {
            try {
                (0, log_1.log)('generalDebug_0003', `Finding the version of "${packageName}" in "${rootPath}".`);
                const moduleName = (0, external_1.getModulePath)(rootPath, pckg);
                const packageJson = yield (0, io_2.findFile)(moduleName, 'package.json');
                const root = (0, path_1.dirname)(packageJson);
                const { version } = yield (0, io_2.readJson)(root, 'package.json');
                return version;
            }
            catch (_a) { }
        }
        (0, log_1.log)('cannotResolveDependency_0053', packages, rootPath);
        return 'latest';
    });
}
exports.findPackageVersion = findPackageVersion;
function flattenExternals(dependencies) {
    return dependencies.map((m) => m.name).filter(utils_1.onlyUnique);
}
exports.flattenExternals = flattenExternals;
function retrieveExternals(root, packageInfo) {
    var _a;
    return __awaiter(this, void 0, void 0, function* () {
        const sharedDependencies = yield (0, importmap_1.readImportmap)(root, packageInfo);
        if (sharedDependencies.length === 0) {
            const allDeps = Object.assign(Object.assign({}, packageInfo.devDependencies), packageInfo.dependencies);
            const deps = (_a = packageInfo.pilets) === null || _a === void 0 ? void 0 : _a.externals;
            const externals = yield (0, npm_2.makeExternals)(root, allDeps, deps);
            return externals.map((ext) => ({
                id: ext,
                name: ext,
                entry: ext,
                type: 'local',
                ref: undefined,
                requireId: ext,
            }));
        }
        return sharedDependencies;
    });
}
exports.retrieveExternals = retrieveExternals;
function retrievePiletsInfo(entryFile) {
    return __awaiter(this, void 0, void 0, function* () {
        const exists = yield (0, io_2.checkExists)(entryFile);
        if (!exists) {
            (0, log_1.fail)('entryPointDoesNotExist_0073', entryFile);
        }
        const packageJson = yield (0, io_2.findFile)(entryFile, 'package.json');
        if (!packageJson) {
            (0, log_1.fail)('packageJsonMissing_0074');
        }
        const root = (0, path_1.dirname)(packageJson);
        const packageInfo = yield (0, io_2.readJson)(root, 'package.json');
        const info = getPiletsInfo(packageInfo);
        const externals = yield retrieveExternals(root, packageInfo);
        const dependencies = {
            std: packageInfo.dependencies || {},
            dev: packageInfo.devDependencies || {},
            peer: packageInfo.peerDependencies || {},
        };
        const framework = constants_1.frameworkLibs.find((lib) => lib in dependencies.std || lib in dependencies.dev);
        return Object.assign(Object.assign({}, info), { externals, name: packageInfo.name, version: packageInfo.version, framework,
            dependencies, scripts: packageInfo.scripts, ignored: checkArrayOrUndefined(packageInfo, 'preservedDependencies'), root });
    });
}
exports.retrievePiletsInfo = retrievePiletsInfo;
function validateSharedDependencies(externals) {
    // See #591 - we should warn in case somebody shared piral packages
    for (const external of externals) {
        const name = external.name;
        if (external.type === 'local' && name.startsWith('piral-') && name.indexOf('/') === -1) {
            (0, log_1.log)('invalidSharedDependency_0029', name);
        }
    }
}
exports.validateSharedDependencies = validateSharedDependencies;
function isValidDependency(name) {
    // super simple check at the moment
    // just to filter out things like "redux-saga/effects" and "@scope/redux-saga/effects"
    return name.indexOf('/') === -1 || (name.indexOf('@') === 0 && name.split('/').length < 3);
}
exports.isValidDependency = isValidDependency;
function patchPiletPackage(root, name, version, piralInfo, fromEmulator, newInfo) {
    return __awaiter(this, void 0, void 0, function* () {
        (0, log_1.log)('generalDebug_0003', `Patching the package.json in "${root}" ...`);
        const pkg = yield getPiletPackage(root, name, version, piralInfo, fromEmulator, newInfo);
        yield (0, io_2.updateExistingJson)(root, 'package.json', pkg);
        (0, log_1.log)('generalDebug_0003', `Succesfully patched the package.json.`);
        yield (0, io_2.updateExistingJson)(root, 'pilet.json', {
            $schema: constants_2.piletJsonSchemaUrl,
            piralInstances: {
                [name]: {},
            },
        });
        (0, log_1.log)('generalDebug_0003', `Succesfully patched the pilet.json.`);
    });
}
exports.patchPiletPackage = patchPiletPackage;
function getPiletPackage(root, name, version, piralInfo, fromEmulator, newInfo) {
    return __awaiter(this, void 0, void 0, function* () {
        const { piralCLI = { version: info_1.cliVersion } } = piralInfo;
        const _a = getPiletsInfo(piralInfo), { packageOverrides } = _a, info = __rest(_a, ["packageOverrides"]);
        const piralDependencies = Object.assign(Object.assign({}, piralInfo.devDependencies), piralInfo.dependencies);
        const toolVersion = piralCLI.version;
        const typeDependencies = newInfo ? (0, language_1.getDevDependencies)(newInfo.language) : {};
        const scripts = newInfo
            ? Object.assign({ start: 'pilet debug', build: 'pilet build', upgrade: 'pilet upgrade' }, info.scripts) : info.scripts;
        const allExternals = yield (0, npm_2.makePiletExternals)(root, piralDependencies, fromEmulator, piralInfo);
        const devDependencies = Object.assign(Object.assign(Object.assign(Object.assign({}, Object.keys(typeDependencies).reduce((deps, name) => {
            deps[name] = piralDependencies[name] || typeDependencies[name];
            return deps;
        }, {})), Object.keys(info.devDependencies).reduce((deps, name) => {
            deps[name] = getDependencyVersion(name, info.devDependencies, piralDependencies);
            return deps;
        }, {})), allExternals.filter(isValidDependency).reduce((deps, name) => {
            const version = piralDependencies[name] || tryFindPackageVersion(name);
            if (version || newInfo) {
                // set only if we have an explicit version or we are in the scaffolding case
                deps[name] = version || 'latest';
            }
            return deps;
        }, {})), { [name]: `${version || piralInfo.version}`, ['piral-cli']: toolVersion });
        if (newInfo) {
            yield appendBundler(devDependencies, newInfo.bundler, toolVersion);
        }
        return (0, merge_1.deepMerge)(packageOverrides, {
            importmap: {
                imports: {},
                inherit: [name],
            },
            devDependencies,
            dependencies: {
                [name]: undefined,
            },
            scripts,
        });
    });
}
/**
 * Returns true if its an emulator package, otherwise it has to be a "raw" app shell.
 */
function checkAppShellPackage(appPackage) {
    const { piralCLI = { generated: false, version: info_1.cliVersion } } = appPackage;
    if (piralCLI.generated) {
        (0, compatibility_1.checkAppShellCompatibility)(piralCLI.version);
        return true;
    }
    (0, log_1.log)('generalDebug_0003', `Missing "piralCLI" section. Assume raw app shell.`);
    return false;
}
exports.checkAppShellPackage = checkAppShellPackage;
function combinePiletExternals(appShells, peerDependencies, peerModules, importmap) {
    const externals = [...Object.keys(peerDependencies), ...peerModules];
    for (let i = importmap.length; i--;) {
        const entry = importmap[i];
        // if the entry has no parents, i.e., it was explicitly mentioned in the importmap
        // then keep it in the importmap (=> prefer the distributed approach, which will always work)
        if (Array.isArray(entry.parents)) {
            // only accept entry as a centrally shared dependency if the entry appears in all
            // mentioned / referenced app shells
            // in other cases (e.g., if one app shell does not share this) use the distributed
            // mechanism to ensure that the dependency can also be resolved in this shell
            if (appShells.every((app) => entry.parents.includes(app))) {
                externals.push(entry.name);
                importmap.splice(i, 1);
            }
        }
    }
    return externals;
}
exports.combinePiletExternals = combinePiletExternals;
function findPiletRoot(proposedRoot) {
    return __awaiter(this, void 0, void 0, function* () {
        const packageJson = yield (0, io_2.findFile)(proposedRoot, 'package.json');
        if (!packageJson) {
            (0, log_1.fail)('packageJsonMissing_0075');
        }
        return (0, path_1.dirname)(packageJson);
    });
}
exports.findPiletRoot = findPiletRoot;
function retrievePiletData(target, app) {
    return __awaiter(this, void 0, void 0, function* () {
        const piletJson = yield (0, io_2.findFile)(target, 'pilet.json');
        const proposedRoot = piletJson ? (0, path_1.dirname)(piletJson) : target;
        const root = yield findPiletRoot(proposedRoot);
        const piletPackage = yield (0, io_2.readJson)(root, 'package.json');
        const piletDefinition = piletJson && (yield (0, io_2.readJson)(proposedRoot, 'pilet.json'));
        const appPackages = yield findPiralInstances(app && [app], piletPackage, piletDefinition, target);
        const apps = [];
        if (appPackages.length === 0) {
            (0, log_1.fail)('appInstancesNotGiven_0012');
        }
        for (const appPackage of appPackages) {
            const appFile = appPackage === null || appPackage === void 0 ? void 0 : appPackage.app;
            const appRoot = appPackage === null || appPackage === void 0 ? void 0 : appPackage.root;
            const appPort = appPackage === null || appPackage === void 0 ? void 0 : appPackage.port;
            if (!appFile || !appRoot) {
                (0, log_1.fail)('appInstanceInvalid_0011');
            }
            const emulator = checkAppShellPackage(appPackage);
            apps.push({
                appPackage,
                appFile,
                appRoot,
                emulator,
                appPort,
            });
        }
        const importmap = yield (0, importmap_1.readImportmap)(root, piletPackage);
        return {
            dependencies: piletPackage.dependencies || {},
            devDependencies: piletPackage.devDependencies || {},
            peerDependencies: piletPackage.peerDependencies || {},
            peerModules: piletPackage.peerModules || [],
            ignored: checkArrayOrUndefined(piletPackage, 'preservedDependencies'),
            schema: piletDefinition === null || piletDefinition === void 0 ? void 0 : piletDefinition.schemaVersion,
            importmap,
            apps,
            piletPackage,
            root,
        };
    });
}
exports.retrievePiletData = retrievePiletData;
//# sourceMappingURL=package.js.map