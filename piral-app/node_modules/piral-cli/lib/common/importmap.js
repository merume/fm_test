"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.readImportmap = void 0;
const path_1 = require("path");
const log_1 = require("./log");
const version_1 = require("./version");
const hash_1 = require("./hash");
const io_1 = require("./io");
const npm_1 = require("./npm");
const shorthandsUrls = ['', '.', '...'];
function addLocalDependencies(dependencies, realIdentifier, identifier, version, requireVersion, entry, assetName) {
    const alias = realIdentifier !== identifier ? realIdentifier : undefined;
    dependencies.push({
        id: `${identifier}@${version}`,
        requireId: `${identifier}@${requireVersion}`,
        entry,
        name: identifier,
        ref: `${assetName}.js`,
        type: 'local',
        alias,
    });
}
function getDependencyDetails(depName) {
    const sep = depName.indexOf('@', 1);
    const version = sep > 0 ? depName.substring(sep + 1) : '';
    const id = sep > 0 ? depName.substring(0, sep) : depName;
    const assetName = (id.startsWith('@') ? id.substring(1) : id).replace(/[\/\.]/g, '-').replace(/(\-)+/, '-');
    return [assetName, id, version];
}
function getLocalDependencyVersion(packageJson, depName, versionSpec) {
    return __awaiter(this, void 0, void 0, function* () {
        const packageDir = (0, path_1.dirname)(packageJson);
        const packageFile = (0, path_1.basename)(packageJson);
        const details = yield (0, io_1.readJson)(packageDir, packageFile);
        if (versionSpec) {
            if (!(0, version_1.validate)(versionSpec)) {
                (0, log_1.fail)('importMapVersionSpecInvalid_0026', depName);
            }
            if (!(0, version_1.satisfies)(details.version, versionSpec)) {
                (0, log_1.fail)('importMapVersionSpecNotSatisfied_0025', depName, details.version);
            }
            return [details.name, details.version, versionSpec];
        }
        return [details.name, details.version, details.version];
    });
}
function getInheritedDependencies(inheritedImport, dir) {
    return __awaiter(this, void 0, void 0, function* () {
        const packageJson = (0, npm_1.tryResolvePackage)(`${inheritedImport}/package.json`, dir);
        if (packageJson) {
            const packageDir = (0, path_1.dirname)(packageJson);
            const packageDetails = yield (0, io_1.readJson)(packageDir, 'package.json');
            return readImportmap(packageDir, packageDetails, true);
        }
        else {
            const directImportmap = (0, npm_1.tryResolvePackage)(inheritedImport, dir);
            if (directImportmap) {
                const baseDir = (0, path_1.dirname)(directImportmap);
                const content = yield (0, io_1.readJson)(baseDir, (0, path_1.basename)(directImportmap));
                return yield resolveImportmap(baseDir, content);
            }
        }
        return [];
    });
}
function resolveImportmap(dir, importmap) {
    return __awaiter(this, void 0, void 0, function* () {
        const dependencies = [];
        const sharedImports = importmap === null || importmap === void 0 ? void 0 : importmap.imports;
        const inheritedImports = importmap === null || importmap === void 0 ? void 0 : importmap.inherit;
        if (typeof sharedImports === 'object' && sharedImports) {
            for (const depName of Object.keys(sharedImports)) {
                const url = sharedImports[depName];
                const [assetName, identifier, versionSpec] = getDependencyDetails(depName);
                if (typeof url !== 'string') {
                    (0, log_1.log)('generalInfo_0000', `The value of "${depName}" in the importmap is not a string and will be ignored.`);
                }
                else if (/^https?:\/\//.test(url)) {
                    const hash = (0, hash_1.computeHash)(url).substring(0, 7);
                    dependencies.push({
                        id: `${identifier}@${hash}`,
                        requireId: `${identifier}@${hash}`,
                        entry: url,
                        name: identifier,
                        ref: url,
                        type: 'remote',
                    });
                }
                else if (url === identifier || shorthandsUrls.includes(url)) {
                    const entry = (0, npm_1.tryResolvePackage)(identifier, dir);
                    if (entry) {
                        const packageJson = yield (0, io_1.findFile)((0, path_1.dirname)(entry), 'package.json');
                        const [realIdentifier, version, requireVersion] = yield getLocalDependencyVersion(packageJson, depName, versionSpec);
                        addLocalDependencies(dependencies, realIdentifier, identifier, version, requireVersion, entry, assetName);
                    }
                    else {
                        (0, log_1.fail)('importMapReferenceNotFound_0027', dir, identifier);
                    }
                }
                else if (!url.startsWith('.') && !(0, path_1.isAbsolute)(url)) {
                    const entry = (0, npm_1.tryResolvePackage)(url, dir);
                    if (entry) {
                        const packageJson = yield (0, io_1.findFile)((0, path_1.dirname)(entry), 'package.json');
                        const [realIdentifier, version, requireVersion] = yield getLocalDependencyVersion(packageJson, depName, versionSpec);
                        addLocalDependencies(dependencies, realIdentifier, identifier, version, requireVersion, entry, assetName);
                    }
                    else {
                        (0, log_1.fail)('importMapReferenceNotFound_0027', dir, url);
                    }
                }
                else {
                    const entry = (0, path_1.resolve)(dir, url);
                    const exists = yield (0, io_1.checkExists)(entry);
                    if (exists) {
                        const isDirectory = yield (0, io_1.checkIsDirectory)(entry);
                        const packageJson = isDirectory
                            ? (0, path_1.resolve)(entry, 'package.json')
                            : yield (0, io_1.findFile)((0, path_1.dirname)(entry), 'package.json');
                        const packageJsonExists = yield (0, io_1.checkExists)(packageJson);
                        if (packageJsonExists) {
                            const [realIdentifier, version, requireVersion] = yield getLocalDependencyVersion(packageJson, depName, versionSpec);
                            addLocalDependencies(dependencies, realIdentifier, identifier, version, requireVersion, isDirectory ? (0, npm_1.tryResolvePackage)(entry, dir) : entry, assetName);
                        }
                        else if (isDirectory) {
                            (0, log_1.fail)('importMapReferenceNotFound_0027', entry, 'package.json');
                        }
                        else {
                            const hash = yield (0, io_1.getHash)(entry);
                            dependencies.push({
                                id: `${identifier}@${hash}`,
                                requireId: `${identifier}@${hash}`,
                                entry,
                                name: identifier,
                                ref: `${assetName}.js`,
                                type: 'local',
                            });
                        }
                    }
                    else {
                        (0, log_1.fail)('importMapReferenceNotFound_0027', dir, url);
                    }
                }
            }
        }
        if (Array.isArray(inheritedImports)) {
            for (const inheritedImport of inheritedImports) {
                const otherDependencies = yield getInheritedDependencies(inheritedImport, dir);
                for (const dependency of otherDependencies) {
                    const entry = dependencies.find((dep) => dep.name === dependency.name);
                    if (!entry) {
                        dependencies.push(Object.assign(Object.assign({}, dependency), { parents: [inheritedImport] }));
                    }
                    else if (Array.isArray(entry.parents)) {
                        entry.parents.push(inheritedImport);
                    }
                }
            }
        }
        return dependencies;
    });
}
function readImportmap(dir, packageDetails, inherited = false) {
    var _a, _b;
    return __awaiter(this, void 0, void 0, function* () {
        const importmap = packageDetails.importmap;
        if (typeof importmap === 'string') {
            const notFound = {};
            const content = yield (0, io_1.readJson)(dir, importmap, notFound);
            if (content === notFound) {
                (0, log_1.fail)('importMapFileNotFound_0028', dir, importmap);
            }
            const baseDir = (0, path_1.dirname)((0, path_1.resolve)(dir, importmap));
            return yield resolveImportmap(baseDir, content);
        }
        else if (typeof importmap === 'undefined' && inherited) {
            // Fall back to sharedDependencies or pilets.external if available
            const shared = (_a = packageDetails.sharedDependencies) !== null && _a !== void 0 ? _a : (_b = packageDetails.pilets) === null || _b === void 0 ? void 0 : _b.externals;
            if (Array.isArray(shared)) {
                return shared.map((dep) => ({
                    id: dep,
                    name: dep,
                    entry: dep,
                    type: 'local',
                    ref: undefined,
                    requireId: dep,
                }));
            }
        }
        return yield resolveImportmap(dir, importmap);
    });
}
exports.readImportmap = readImportmap;
//# sourceMappingURL=importmap.js.map