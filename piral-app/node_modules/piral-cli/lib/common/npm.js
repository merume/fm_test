"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.makeExternals = exports.mergeExternals = exports.makePiletExternals = exports.getPackageVersion = exports.getGitPackageVersion = exports.getFilePackageVersion = exports.getPackageName = exports.combinePackageRef = exports.isLinkedPackage = exports.findPackageRoot = exports.tryResolvePackage = exports.getCurrentPackageDetails = exports.dissectPackageName = exports.makeFilePath = exports.makeGitUrl = exports.isGitPackage = exports.makeNpmAlias = exports.isNpmPackage = exports.isLocalPackage = exports.findLatestVersion = exports.findSpecificVersion = exports.findNpmTarball = exports.createNpmPackage = exports.publishNpmPackage = exports.initNpmProject = exports.installNpmPackage = exports.uninstallNpmPackage = exports.installNpmPackageFromOptionalRegistry = exports.installNpmDependencies = exports.isMonorepoPackageRef = exports.determineNpmClient = void 0;
const path_1 = require("path");
const fs_1 = require("fs");
const log_1 = require("./log");
const clients_1 = require("./clients");
const config_1 = require("./config");
const constants_1 = require("./constants");
const inspect_1 = require("./inspect");
const io_1 = require("./io");
const helpers_1 = require("../helpers");
const external_1 = require("../external");
const gitPrefix = 'git+';
const filePrefix = 'file:';
const npmPrefix = 'npm:';
const pathPrefixes = ['/', './', '../', '.\\', '..\\', '~/', '~\\', filePrefix];
function isProjectReference(name) {
    const target = (0, path_1.resolve)(name, constants_1.packageJson);
    return (0, io_1.checkExists)(target);
}
function resolveAbsPath(basePath, fullName) {
    const prefixed = fullName.startsWith(filePrefix);
    const relPath = !prefixed ? fullName : fullName.replace(filePrefix, '');
    return (0, path_1.resolve)(basePath, relPath);
}
function detectMonorepoRoot(root) {
    return __awaiter(this, void 0, void 0, function* () {
        let previous = root;
        do {
            if (yield (0, io_1.checkExists)((0, path_1.resolve)(root, 'lerna.json'))) {
                return [root, 'lerna'];
            }
            if (yield (0, io_1.checkExists)((0, path_1.resolve)(root, 'rush.json'))) {
                return [root, 'rush'];
            }
            if (yield (0, io_1.checkExists)((0, path_1.resolve)(root, 'pnpm-workspace.yaml'))) {
                return [root, 'pnpm'];
            }
            const pj = yield (0, io_1.readJson)(root, constants_1.packageJson);
            if (Array.isArray(pj === null || pj === void 0 ? void 0 : pj.workspaces)) {
                if (yield (0, io_1.checkExists)((0, path_1.resolve)(root, '.pnp.cjs'))) {
                    return [root, 'pnp'];
                }
                if (yield (0, io_1.checkExists)((0, path_1.resolve)(root, 'yarn.lock'))) {
                    return [root, 'yarn'];
                }
                return [root, 'npm'];
            }
            previous = root;
            root = (0, path_1.dirname)(root);
        } while (root !== previous);
        return [];
    });
}
/**
 * For details about how this works consult issue
 * https://github.com/smapiot/piral/issues/203
 * @param root The project's root directory.
 */
function determineNpmClient(root, selected) {
    return __awaiter(this, void 0, void 0, function* () {
        if (!selected || !helpers_1.clientTypeKeys.includes(selected)) {
            (0, log_1.log)('generalDebug_0003', 'No npm client selected. Checking for lock or config files ...');
            const searchedClients = yield (0, clients_1.detectClients)(root);
            const foundClients = searchedClients.filter((m) => m.result);
            (0, log_1.log)('generalDebug_0003', `Results of the lock file check: ${searchedClients.map((m) => `${m.client}=${m.result}`).join(', ')}`);
            if (foundClients.length > 1) {
                const wrapperClient = foundClients.find((m) => (0, clients_1.isWrapperClient)(m.client));
                if (wrapperClient) {
                    const { client } = wrapperClient;
                    (0, log_1.log)('generalDebug_0003', `Found valid wrapper client via lock or config file: "${client}".`);
                }
            }
            if (foundClients.length > 0) {
                const { client } = foundClients[0];
                if (foundClients.length > 1) {
                    const clientStr = `"${foundClients.map((m) => m.client).join('", "')}"`;
                    (0, log_1.log)('generalWarning_0001', `Found multiple clients via their lock or config files: ${clientStr}.`);
                }
                (0, log_1.log)('generalDebug_0003', `Found valid direct client via lock or config file: "${client}".`);
                return client;
            }
            const defaultClient = config_1.config.npmClient;
            if (helpers_1.clientTypeKeys.includes(defaultClient)) {
                (0, log_1.log)('generalDebug_0003', `Using the default client: "${defaultClient}".`);
                return defaultClient;
            }
            (0, log_1.log)('generalDebug_0003', 'Using the fallback "npm" client.');
            return 'npm';
        }
        return selected;
    });
}
exports.determineNpmClient = determineNpmClient;
function isMonorepoPackageRef(refName, root) {
    return __awaiter(this, void 0, void 0, function* () {
        const [monorepoRoot, client] = yield detectMonorepoRoot(root);
        if (monorepoRoot) {
            const c = clients_1.clients[client];
            return yield c.isProject(monorepoRoot, refName);
        }
        return false;
    });
}
exports.isMonorepoPackageRef = isMonorepoPackageRef;
function installNpmDependencies(client, target = '.') {
    const { installDependencies } = clients_1.clients[client];
    return installDependencies(target);
}
exports.installNpmDependencies = installNpmDependencies;
function installNpmPackageFromOptionalRegistry(packageRef, target = '.', registry) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            yield installNpmPackage('npm', packageRef, target, '--registry', registry);
        }
        catch (e) {
            if (registry === constants_1.defaultRegistry) {
                throw e;
            }
            yield installNpmPackage('npm', packageRef, target, '--registry', constants_1.defaultRegistry);
        }
    });
}
exports.installNpmPackageFromOptionalRegistry = installNpmPackageFromOptionalRegistry;
function uninstallNpmPackage(client, packageRef, target = '.', ...flags) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            const { uninstallPackage } = clients_1.clients[client];
            return yield uninstallPackage(packageRef, target, ...flags);
        }
        catch (ex) {
            (0, log_1.log)('generalError_0002', `Could not uninstall the package "${packageRef}" using ${client}. Make sure ${client} is correctly installed and accessible: ${ex}`);
            throw ex;
        }
    });
}
exports.uninstallNpmPackage = uninstallNpmPackage;
function installNpmPackage(client, packageRef, target = '.', ...flags) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            const { installPackage } = clients_1.clients[client];
            return yield installPackage(packageRef, target, ...flags);
        }
        catch (ex) {
            (0, log_1.log)('generalError_0002', `Could not install the package "${packageRef}" using ${client}. Make sure ${client} is correctly installed and accessible: ${ex}`);
            throw ex;
        }
    });
}
exports.installNpmPackage = installNpmPackage;
function initNpmProject(client, projectName, target) {
    const { initProject } = clients_1.clients[client];
    return initProject(projectName, target);
}
exports.initNpmProject = initNpmProject;
function publishNpmPackage(target = '.', file = '*.tgz', flags = [], interactive = false) {
    const { publishPackage, loginUser } = clients_1.clients.npm;
    return publishPackage(target, file, ...flags).catch(err => {
        if (!interactive) {
            throw err;
        }
        return loginUser().then(() => publishNpmPackage(target, file, flags, false));
    });
}
exports.publishNpmPackage = publishNpmPackage;
function createNpmPackage(target = '.') {
    const { createPackage } = clients_1.clients.npm;
    return createPackage(target);
}
exports.createNpmPackage = createNpmPackage;
function findNpmTarball(packageRef) {
    const { findTarball } = clients_1.clients.npm;
    return findTarball(packageRef);
}
exports.findNpmTarball = findNpmTarball;
function findSpecificVersion(packageName, version) {
    const { findSpecificVersion } = clients_1.clients.npm;
    return findSpecificVersion(packageName, version);
}
exports.findSpecificVersion = findSpecificVersion;
function findLatestVersion(packageName) {
    const { findSpecificVersion } = clients_1.clients.npm;
    return findSpecificVersion(packageName, 'latest');
}
exports.findLatestVersion = findLatestVersion;
function isLocalPackage(baseDir, fullName) {
    (0, log_1.log)('generalDebug_0003', 'Checking if its a local package ...');
    if (fullName) {
        if (pathPrefixes.some((prefix) => fullName.startsWith(prefix))) {
            (0, log_1.log)('generalDebug_0003', 'Found a local package by name.');
            return true;
        }
        else if (fullName.endsWith('.tgz')) {
            (0, log_1.log)('generalDebug_0003', ' Verifying if local path exists ...');
            if ((0, fs_1.existsSync)((0, path_1.resolve)(baseDir, fullName))) {
                (0, log_1.log)('generalDebug_0003', 'Found a potential local package by path.');
                return true;
            }
        }
        return fullName.startsWith(filePrefix);
    }
    return false;
}
exports.isLocalPackage = isLocalPackage;
function isNpmPackage(fullName) {
    (0, log_1.log)('generalDebug_0003', 'Checking if its an npm alias ...');
    if (fullName) {
        const npmed = fullName.startsWith(npmPrefix);
        if (npmed && fullName.substring(npmPrefix.length + 1).indexOf('@') !== -1) {
            (0, log_1.log)('generalDebug_0003', 'Found an npm package alias by name.');
            return true;
        }
    }
    return false;
}
exports.isNpmPackage = isNpmPackage;
function makeNpmAlias(name, version) {
    return `${npmPrefix}${name}@${version}`;
}
exports.makeNpmAlias = makeNpmAlias;
function isGitPackage(fullName) {
    (0, log_1.log)('generalDebug_0003', 'Checking if its a Git package ...');
    if (fullName) {
        const gitted = fullName.startsWith(gitPrefix);
        if (gitted || /^(https?|ssh):\/\/.*\.git$/.test(fullName)) {
            (0, log_1.log)('generalDebug_0003', 'Found a Git package by name.');
            return true;
        }
    }
    return false;
}
exports.isGitPackage = isGitPackage;
function makeGitUrl(fullName) {
    const gitted = fullName.startsWith(gitPrefix);
    return gitted ? fullName : `${gitPrefix}${fullName}`;
}
exports.makeGitUrl = makeGitUrl;
function makeFilePath(basePath, fullName) {
    const absPath = resolveAbsPath(basePath, fullName);
    return `${filePrefix}${absPath}`;
}
exports.makeFilePath = makeFilePath;
/**
 * Looks at the provided package name and normalizes it
 * resulting in the following tuple:
 * [
 *   normalized / real package name,
 *   found package version / version identifier,
 *   indicator if an explicit version was used,
 *   the used package type
 * ]
 * @param baseDir The base directory of the current operation.
 * @param fullName The provided package name.
 */
function dissectPackageName(baseDir, fullName) {
    return __awaiter(this, void 0, void 0, function* () {
        if (isGitPackage(fullName)) {
            const gitUrl = makeGitUrl(fullName);
            return [gitUrl, 'latest', false, 'git'];
        }
        else if (isLocalPackage(baseDir, fullName)) {
            const fullPath = resolveAbsPath(baseDir, fullName);
            const exists = yield (0, io_1.checkExists)(fullPath);
            if (!exists) {
                (0, log_1.fail)('scaffoldPathDoesNotExist_0030', fullPath);
            }
            const isReference = yield isProjectReference(fullPath);
            if (isReference) {
                (0, log_1.fail)('projectReferenceNotSupported_0032', fullPath);
            }
            return [fullPath, 'latest', false, 'file'];
        }
        else {
            const index = fullName.indexOf('@', 1);
            const type = 'registry';
            if (index !== -1) {
                return [fullName.substring(0, index), fullName.substring(index + 1), true, type];
            }
            return [fullName, 'latest', false, type];
        }
    });
}
exports.dissectPackageName = dissectPackageName;
/**
 * Looks at the current package name / version and
 * normalizes it resulting in the following tuple:
 * [
 *   normalized / real package name,
 *   found package version / version identifier,
 * ]
 * @param baseDir The base directory of the current operation.
 * @param sourceName The used package name.
 * @param sourceVersion The used package version.
 * @param desired The desired package version.
 */
function getCurrentPackageDetails(baseDir, sourceName, sourceVersion, desired, root) {
    return __awaiter(this, void 0, void 0, function* () {
        (0, log_1.log)('generalDebug_0003', `Checking package details in "${baseDir}" ...`);
        if (isLocalPackage(baseDir, desired)) {
            const fullPath = (0, path_1.resolve)(baseDir, desired);
            const exists = yield (0, io_1.checkExists)(fullPath);
            if (!exists) {
                (0, log_1.fail)('upgradePathDoesNotExist_0031', fullPath);
            }
            const isReference = yield isProjectReference(fullPath);
            if (isReference) {
                (0, log_1.fail)('projectReferenceNotSupported_0032', fullPath);
            }
            return [fullPath, getFilePackageVersion(fullPath, root)];
        }
        else if (isGitPackage(desired)) {
            const gitUrl = makeGitUrl(desired);
            return [gitUrl, getGitPackageVersion(gitUrl)];
        }
        else if (sourceVersion && sourceVersion.startsWith('file:')) {
            (0, log_1.log)('localeFileForUpgradeMissing_0050');
        }
        else if (sourceVersion && sourceVersion.startsWith('git+')) {
            if (desired === 'latest') {
                const gitUrl = desired;
                return [gitUrl, getGitPackageVersion(gitUrl)];
            }
            else {
                (0, log_1.log)('gitLatestForUpgradeMissing_0051');
            }
        }
        return [combinePackageRef(sourceName, desired, 'registry'), desired];
    });
}
exports.getCurrentPackageDetails = getCurrentPackageDetails;
function tryResolve(packageName, baseDir = process.cwd()) {
    try {
        return (0, external_1.getModulePath)(baseDir, packageName);
    }
    catch (_a) {
        return undefined;
    }
}
function tryResolvePackage(name, baseDir = undefined) {
    const path = baseDir ? tryResolve(name, baseDir) : tryResolve(name);
    const root = baseDir || process.cwd();
    if (!path) {
        (0, log_1.log)('generalDebug_0003', `Could not resolve the package "${name}" in "${root}".`);
    }
    else {
        (0, log_1.log)('generalVerbose_0004', `Resolved the package "${name}" (from "${root}") to be "${path}".`);
    }
    return path;
}
exports.tryResolvePackage = tryResolvePackage;
function findPackageRoot(pck, baseDir) {
    return tryResolvePackage(`${pck}/${constants_1.packageJson}`, baseDir);
}
exports.findPackageRoot = findPackageRoot;
function isLinkedPackage(name, type, hadVersion, target) {
    if (type === 'registry' && !hadVersion) {
        const root = findPackageRoot(name, target);
        return typeof root === 'string';
    }
    return false;
}
exports.isLinkedPackage = isLinkedPackage;
function combinePackageRef(name, version, type) {
    if (type === 'registry') {
        const tag = version || 'latest';
        return `${name}@${tag}`;
    }
    return name;
}
exports.combinePackageRef = combinePackageRef;
function getPackageName(root, name, type) {
    return __awaiter(this, void 0, void 0, function* () {
        switch (type) {
            case 'file':
                const originalPackageJson = yield (0, io_1.readJson)(name, constants_1.packageJson);
                if (!originalPackageJson.name) {
                    const p = (0, path_1.resolve)(process.cwd(), name);
                    try {
                        const s = (0, fs_1.createReadStream)(p);
                        const i = yield (0, inspect_1.inspectPackage)(s);
                        return i.name;
                    }
                    catch (err) {
                        (0, log_1.log)('generalError_0002', `Could not open package tarball at "${p}": "${err}`);
                        return undefined;
                    }
                }
                return originalPackageJson.name;
            case 'git':
                const pj = yield (0, io_1.readJson)(root, constants_1.packageJson);
                const dd = pj.devDependencies || {};
                return Object.keys(dd).filter((dep) => dd[dep] === name)[0];
            case 'registry':
                return name;
        }
    });
}
exports.getPackageName = getPackageName;
function getFilePackageVersion(sourceName, root) {
    const path = (0, path_1.relative)(root, sourceName);
    return `${filePrefix}${path}`;
}
exports.getFilePackageVersion = getFilePackageVersion;
function getGitPackageVersion(sourceName) {
    return `${sourceName}`;
}
exports.getGitPackageVersion = getGitPackageVersion;
function getPackageVersion(hadVersion, sourceName, sourceVersion, type, root) {
    switch (type) {
        case 'registry':
            return hadVersion && sourceVersion;
        case 'file':
            return getFilePackageVersion(sourceName, root);
        case 'git':
            return getGitPackageVersion(sourceName);
    }
}
exports.getPackageVersion = getPackageVersion;
function getExternalsFrom(root, packageName) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            const target = (0, external_1.getModulePath)(root, `${packageName}/${constants_1.packageJson}`);
            const dir = (0, path_1.dirname)(target);
            const { sharedDependencies } = yield (0, io_1.readJson)(dir, constants_1.packageJson);
            return sharedDependencies;
        }
        catch (err) {
            (0, log_1.log)('generalError_0002', `Could not get externals from "${packageName}": "${err}`);
            return undefined;
        }
    });
}
function getCoreExternals(root, dependencies) {
    return __awaiter(this, void 0, void 0, function* () {
        for (const frameworkLib of constants_1.frameworkLibs) {
            if (dependencies[frameworkLib]) {
                const deps = yield getExternalsFrom(root, frameworkLib);
                if (deps) {
                    return deps;
                }
            }
        }
        (0, log_1.log)('frameworkLibMissing_0078', constants_1.frameworkLibs);
        return [];
    });
}
function makePiletExternals(root, dependencies, fromEmulator, piralInfo) {
    return __awaiter(this, void 0, void 0, function* () {
        if (fromEmulator) {
            const { sharedDependencies = constants_1.legacyCoreExternals } = piralInfo;
            return sharedDependencies;
        }
        else {
            return yield getCoreExternals(root, dependencies);
        }
    });
}
exports.makePiletExternals = makePiletExternals;
function mergeExternals(customExternals, coreExternals = []) {
    if (customExternals && Array.isArray(customExternals)) {
        const [include, exclude] = customExternals.reduce((prev, curr) => {
            if (typeof curr === 'string') {
                if (curr.startsWith('!')) {
                    prev[1].push(curr.substring(1));
                }
                else {
                    prev[0].push(curr);
                }
            }
            return prev;
        }, [[], []]);
        const all = exclude.includes('*') ? include : [...include, ...coreExternals];
        return all.filter((m, i, arr) => !exclude.includes(m) && arr.indexOf(m) === i);
    }
    return coreExternals;
}
exports.mergeExternals = mergeExternals;
function makeExternals(root, dependencies, externals) {
    return __awaiter(this, void 0, void 0, function* () {
        const coreExternals = yield getCoreExternals(root, dependencies);
        return mergeExternals(externals, coreExternals);
    });
}
exports.makeExternals = makeExternals;
//# sourceMappingURL=npm.js.map