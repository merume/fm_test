"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.buildPiral = exports.buildPiralDefaults = void 0;
const path_1 = require("path");
const bundler_1 = require("../bundler");
const types_1 = require("../types");
const common_1 = require("../common");
const releaseName = 'release';
const emulatorName = 'emulator';
const emulatorSourcesName = 'emulator-sources';
exports.buildPiralDefaults = {
    entry: './',
    target: './dist',
    publicUrl: '/',
    logLevel: types_1.LogLevels.info,
    fresh: false,
    minify: true,
    type: 'all',
    subdir: true,
    sourceMaps: true,
    watch: false,
    contentHash: true,
    optimizeModules: false,
};
function runLifecycle(root, scripts, type) {
    return __awaiter(this, void 0, void 0, function* () {
        const script = scripts === null || scripts === void 0 ? void 0 : scripts[type];
        if (script) {
            (0, common_1.log)('generalDebug_0003', `Running "${type}" ("${script}") ...`);
            yield (0, common_1.runScript)(script, root);
            (0, common_1.log)('generalDebug_0003', `Finished running "${type}".`);
        }
        else {
            (0, common_1.log)('generalDebug_0003', `No script for "${type}" found ...`);
        }
    });
}
function buildPiral(baseDir = process.cwd(), options = {}) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
    return __awaiter(this, void 0, void 0, function* () {
        const { entry = exports.buildPiralDefaults.entry, target = exports.buildPiralDefaults.target, publicUrl: originalPublicUrl = exports.buildPiralDefaults.publicUrl, logLevel = exports.buildPiralDefaults.logLevel, minify = exports.buildPiralDefaults.minify, sourceMaps = exports.buildPiralDefaults.sourceMaps, watch = exports.buildPiralDefaults.watch, contentHash = exports.buildPiralDefaults.contentHash, subdir = exports.buildPiralDefaults.subdir, fresh = exports.buildPiralDefaults.fresh, type = exports.buildPiralDefaults.type, optimizeModules = exports.buildPiralDefaults.optimizeModules, _ = {}, hooks = {}, bundlerName, } = options;
        const publicUrl = (0, common_1.normalizePublicUrl)(originalPublicUrl);
        const fullBase = (0, path_1.resolve)(process.cwd(), baseDir);
        const useSubdir = type === 'all' || subdir;
        (0, common_1.setLogLevel)(logLevel);
        yield ((_a = hooks.onBegin) === null || _a === void 0 ? void 0 : _a.call(hooks, { options, fullBase }));
        (0, common_1.progress)('Reading configuration ...');
        const entryFiles = yield (0, common_1.retrievePiralRoot)(fullBase, entry);
        const { name, root, ignored, externals, scripts } = yield (0, common_1.retrievePiletsInfo)(entryFiles);
        const piralInstances = [name];
        const dest = (0, common_1.getDestination)(entryFiles, (0, path_1.resolve)(fullBase, target));
        yield (0, common_1.checkCliCompatibility)(root);
        (0, common_1.validateSharedDependencies)(externals);
        if (fresh) {
            (0, common_1.progress)('Removing output directory ...');
            yield (0, common_1.removeDirectory)(dest.outDir);
        }
        // everything except release -> build emulator
        if (type !== releaseName) {
            const emulatorPublicUrl = '/';
            const targetDir = useSubdir ? (0, path_1.join)(dest.outDir, emulatorName) : dest.outDir;
            (0, common_1.progress)('Starting emulator build ...');
            // since we create this anyway let's just pretend we want to have it clean!
            yield (0, common_1.removeDirectory)(targetDir);
            yield ((_b = hooks.beforeBuild) === null || _b === void 0 ? void 0 : _b.call(hooks, { root, publicUrl: emulatorPublicUrl, externals, entryFiles, targetDir, piralInstances }));
            (0, common_1.logInfo)(`Bundle ${emulatorName} ...`);
            const { dir: outDir, name: outFile, hash, } = yield (0, bundler_1.callPiralBuild)({
                root,
                piralInstances,
                emulator: true,
                standalone: false,
                optimizeModules,
                sourceMaps,
                watch,
                contentHash,
                minify: false,
                externals: externals.map(m => m.name),
                publicUrl: emulatorPublicUrl,
                entryFiles,
                logLevel,
                ignored,
                outDir: (0, path_1.join)(targetDir, 'app'),
                outFile: dest.outFile,
                _,
            }, bundlerName);
            yield ((_c = hooks.afterBuild) === null || _c === void 0 ? void 0 : _c.call(hooks, {
                root,
                publicUrl: emulatorPublicUrl,
                externals,
                entryFiles,
                targetDir,
                piralInstances,
                hash,
                outDir,
                outFile,
            }));
            yield runLifecycle(root, scripts, 'piral:postbuild');
            yield runLifecycle(root, scripts, `piral:postbuild-${emulatorName}`);
            yield ((_d = hooks.beforeEmulator) === null || _d === void 0 ? void 0 : _d.call(hooks, { root, externals, targetDir, outDir }));
            const rootDir = yield (0, common_1.createEmulatorSources)(root, externals, outDir, outFile, logLevel);
            yield ((_e = hooks.afterEmulator) === null || _e === void 0 ? void 0 : _e.call(hooks, { root, externals, targetDir, outDir, rootDir }));
            if (type !== emulatorSourcesName) {
                yield ((_f = hooks.beforePackage) === null || _f === void 0 ? void 0 : _f.call(hooks, { root, externals, targetDir, outDir, rootDir }));
                yield (0, common_1.packageEmulator)(rootDir);
                yield ((_g = hooks.afterPackage) === null || _g === void 0 ? void 0 : _g.call(hooks, { root, externals, targetDir, outDir, rootDir }));
                (0, common_1.logDone)(`Emulator package available in "${rootDir}".`);
            }
            else {
                (0, common_1.logDone)(`Emulator sources available in "${rootDir}".`);
            }
            (0, common_1.logReset)();
        }
        // everything except emulator and emulator-soruces -> build release
        if (type !== emulatorName && type !== emulatorSourcesName) {
            const targetDir = useSubdir ? (0, path_1.join)(dest.outDir, releaseName) : dest.outDir;
            (0, common_1.progress)('Starting release build ...');
            // since we create this anyway let's just pretend we want to have it clean!
            yield (0, common_1.removeDirectory)(targetDir);
            (0, common_1.logInfo)(`Bundle ${releaseName} ...`);
            yield ((_h = hooks.beforeBuild) === null || _h === void 0 ? void 0 : _h.call(hooks, { root, publicUrl, externals, entryFiles, targetDir, piralInstances }));
            const { dir: outDir, name: outFile, hash, } = yield (0, bundler_1.callPiralBuild)({
                root,
                piralInstances,
                emulator: false,
                standalone: false,
                optimizeModules,
                sourceMaps,
                watch,
                contentHash,
                minify,
                externals: externals.map(m => m.name),
                publicUrl,
                outFile: dest.outFile,
                outDir: targetDir,
                entryFiles,
                logLevel,
                ignored,
                _,
            }, bundlerName);
            yield ((_j = hooks.afterBuild) === null || _j === void 0 ? void 0 : _j.call(hooks, { root, publicUrl, externals, entryFiles, targetDir, piralInstances, outDir, outFile, hash }));
            yield runLifecycle(root, scripts, 'piral:postbuild');
            yield runLifecycle(root, scripts, `piral:postbuild-${releaseName}`);
            (0, common_1.logDone)(`Files for publication available in "${outDir}".`);
            (0, common_1.logReset)();
        }
        yield ((_k = hooks.onEnd) === null || _k === void 0 ? void 0 : _k.call(hooks, { root }));
    });
}
exports.buildPiral = buildPiral;
//# sourceMappingURL=build-piral.js.map