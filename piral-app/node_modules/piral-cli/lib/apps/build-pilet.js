"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.buildPilet = exports.buildPiletDefaults = void 0;
const path_1 = require("path");
const types_1 = require("../types");
const bundler_1 = require("../bundler");
const common_1 = require("../common");
function createMetadata(outDir, outFile, pilets, publicPath) {
    return (0, common_1.writeJson)(outDir, outFile, pilets.map((p) => (Object.assign({ name: p.package.name, version: p.package.version, link: `${publicPath}${p.id}/${p.outFile}` }, (0, common_1.getPiletSpecMeta)(p.path, `${publicPath}${p.id}/`)))));
}
function copyPilets(outDir, pilets) {
    return Promise.all(pilets.map((p) => __awaiter(this, void 0, void 0, function* () {
        const files = yield (0, common_1.getFileNames)(p.outDir);
        for (const file of files) {
            yield (0, common_1.copy)((0, path_1.resolve)(p.outDir, file), (0, path_1.resolve)(outDir, p.id, file), common_1.ForceOverwrite.yes);
        }
    })));
}
exports.buildPiletDefaults = {
    entry: './src/index',
    target: './dist/index.js',
    publicUrl: '/',
    minify: true,
    logLevel: types_1.LogLevels.info,
    type: 'default',
    fresh: false,
    sourceMaps: true,
    watch: false,
    contentHash: true,
    optimizeModules: false,
    schemaVersion: undefined,
    concurrency: common_1.cpuCount,
    declaration: true,
};
function buildPilet(baseDir = process.cwd(), options = {}) {
    var _a, _b;
    return __awaiter(this, void 0, void 0, function* () {
        const { entry = exports.buildPiletDefaults.entry, target = exports.buildPiletDefaults.target, publicUrl: originalPublicUrl = exports.buildPiletDefaults.publicUrl, logLevel = exports.buildPiletDefaults.logLevel, minify = exports.buildPiletDefaults.minify, sourceMaps = exports.buildPiletDefaults.sourceMaps, watch = exports.buildPiletDefaults.watch, contentHash = exports.buildPiletDefaults.contentHash, fresh = exports.buildPiletDefaults.fresh, concurrency = exports.buildPiletDefaults.concurrency, optimizeModules = exports.buildPiletDefaults.optimizeModules, schemaVersion: originalSchemaVersion = exports.buildPiletDefaults.schemaVersion, declaration = exports.buildPiletDefaults.declaration, type = exports.buildPiletDefaults.type, _ = {}, hooks = {}, bundlerName, app, } = options;
        const publicUrl = (0, common_1.normalizePublicUrl)(originalPublicUrl);
        const fullBase = (0, path_1.resolve)(process.cwd(), baseDir);
        const entryList = Array.isArray(entry) ? entry : [entry];
        (0, common_1.setLogLevel)(logLevel);
        yield ((_a = hooks.onBegin) === null || _a === void 0 ? void 0 : _a.call(hooks, { options, fullBase }));
        (0, common_1.progress)('Reading configuration ...');
        const allEntries = yield (0, common_1.matchAnyPilet)(fullBase, entryList);
        (0, common_1.log)('generalDebug_0003', `Found the following entries: ${allEntries.join(', ')}`);
        if (allEntries.length === 0) {
            (0, common_1.fail)('entryFileMissing_0077');
        }
        const pilets = yield (0, common_1.concurrentWorkers)(allEntries, concurrency, (entryModule) => __awaiter(this, void 0, void 0, function* () {
            var _c, _d, _e, _f;
            const targetDir = (0, path_1.dirname)(entryModule);
            const { peerDependencies, peerModules, root, apps, piletPackage, ignored, importmap, schema } = yield (0, common_1.retrievePiletData)(targetDir, app);
            const schemaVersion = originalSchemaVersion || schema || common_1.config.schemaVersion || 'v2';
            const piralInstances = apps.map(m => m.appPackage.name);
            const externals = (0, common_1.combinePiletExternals)(piralInstances, peerDependencies, peerModules, importmap);
            const dest = (0, path_1.resolve)(root, target);
            const outDir = (0, path_1.dirname)(dest);
            const outFile = (0, path_1.basename)(dest);
            (0, common_1.validateSharedDependencies)(importmap);
            if (fresh) {
                (0, common_1.progress)('Removing output directory ...');
                yield (0, common_1.removeDirectory)(outDir);
            }
            (0, common_1.logInfo)('Bundle pilet ...');
            yield ((_c = hooks.beforeBuild) === null || _c === void 0 ? void 0 : _c.call(hooks, { root, outDir, importmap, entryModule, schemaVersion, piletPackage }));
            yield (0, bundler_1.callPiletBuild)({
                root,
                piralInstances,
                optimizeModules,
                sourceMaps,
                watch,
                contentHash,
                minify,
                externals,
                targetDir,
                importmap,
                outFile,
                outDir,
                entryModule: `./${(0, path_1.relative)(root, entryModule)}`,
                logLevel,
                version: schemaVersion,
                ignored,
                _,
            }, bundlerName);
            yield ((_d = hooks.afterBuild) === null || _d === void 0 ? void 0 : _d.call(hooks, { root, outDir, importmap, entryModule, schemaVersion, piletPackage }));
            if (declaration) {
                yield ((_e = hooks.beforeDeclaration) === null || _e === void 0 ? void 0 : _e.call(hooks, { root, outDir, entryModule, piletPackage }));
                yield (0, common_1.createPiletDeclaration)(piletPackage.name, root, entryModule, externals, outDir, common_1.ForceOverwrite.yes, logLevel);
                yield ((_f = hooks.afterDeclaration) === null || _f === void 0 ? void 0 : _f.call(hooks, { root, outDir, entryModule, piletPackage }));
            }
            (0, common_1.logDone)(`Pilet "${piletPackage.name}" built successfully!`);
            return {
                id: piletPackage.name.replace(/[^a-zA-Z0-9\-]/gi, ''),
                root,
                apps,
                outDir,
                outFile,
                path: dest,
                package: piletPackage,
            };
        }));
        if (type === 'standalone') {
            const distDir = (0, path_1.dirname)((0, path_1.resolve)(fullBase, target));
            const outDir = (0, path_1.resolve)(distDir, 'standalone');
            const { apps, root } = pilets[0];
            const { appPackage, appFile } = apps[0];
            const piralInstances = [appPackage.name];
            const isEmulator = (0, common_1.checkAppShellPackage)(appPackage);
            (0, common_1.logInfo)('Building standalone solution ...');
            yield (0, common_1.removeDirectory)(outDir);
            (0, common_1.progress)('Copying files ...');
            yield copyPilets(outDir, pilets);
            yield createMetadata(outDir, '$pilet-api', pilets, publicUrl);
            if (isEmulator) {
                // in case of an emulator assets are not "seen" by the bundler, so we
                // just copy overthing over - this should work in most cases.
                yield (0, common_1.copy)((0, path_1.dirname)(appFile), outDir, common_1.ForceOverwrite.yes);
                (0, common_1.progress)('Optimizing app shell ...');
                // we don't need to care about externals or other things that are already
                // part of the emulator
                yield (0, bundler_1.callPiralBuild)({
                    root,
                    piralInstances,
                    emulator: false,
                    standalone: true,
                    optimizeModules: false,
                    sourceMaps,
                    watch: false,
                    contentHash,
                    minify,
                    externals: [],
                    publicUrl,
                    outFile: 'index.html',
                    outDir,
                    entryFiles: appFile,
                    logLevel,
                    ignored: [],
                    _,
                }, bundlerName);
            }
            else {
                // in this case we can just do the same steps as if
                const { ignored, externals } = yield (0, common_1.retrievePiletsInfo)(appFile);
                yield (0, bundler_1.callPiralBuild)({
                    root,
                    piralInstances,
                    emulator: false,
                    standalone: true,
                    optimizeModules: false,
                    sourceMaps,
                    watch: false,
                    contentHash,
                    minify,
                    externals: externals.map(m => m.name),
                    publicUrl,
                    outFile: 'index.html',
                    outDir,
                    entryFiles: appFile,
                    logLevel,
                    ignored,
                    _,
                }, bundlerName);
            }
            (0, common_1.logDone)(`Standalone app available at "${outDir}"!`);
        }
        else if (type === 'manifest') {
            const manifest = 'pilets.json';
            const outDir = (0, path_1.dirname)((0, path_1.resolve)(fullBase, target));
            (0, common_1.logInfo)('Building pilet manifest ...');
            (0, common_1.progress)('Copying files ...');
            yield copyPilets(outDir, pilets);
            yield createMetadata(outDir, manifest, pilets, publicUrl);
            (0, common_1.logDone)(`Manifest available at "${outDir}/${manifest}"!`);
        }
        yield ((_b = hooks.onEnd) === null || _b === void 0 ? void 0 : _b.call(hooks, {}));
    });
}
exports.buildPilet = buildPilet;
//# sourceMappingURL=build-pilet.js.map