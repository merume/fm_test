"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.debugPilet = exports.debugPiletDefaults = void 0;
const path_1 = require("path");
const bundler_1 = require("../bundler");
const types_1 = require("../types");
const common_1 = require("../common");
exports.debugPiletDefaults = {
    logLevel: types_1.LogLevels.info,
    target: './dist/index.js',
    entry: './src/index',
    open: common_1.config.openBrowser,
    port: common_1.config.port,
    publicUrl: '/',
    hmr: true,
    krasrc: undefined,
    optimizeModules: false,
    schemaVersion: undefined,
    concurrency: common_1.cpuCount,
};
function byPort(a, b) {
    return a[1] - b[1];
}
function getOrMakeApps({ apps, publicUrl }, logLevel) {
    return Promise.all(apps.map(({ emulator, appFile, appPackage, appPort }) => __awaiter(this, void 0, void 0, function* () {
        if (!emulator) {
            const piralInstances = [appPackage.name];
            const { externals, root, ignored } = yield (0, common_1.retrievePiletsInfo)(appFile);
            const { dir } = yield (0, bundler_1.callDebugPiralFromMonoRepo)({
                root,
                optimizeModules: false,
                publicUrl,
                ignored,
                externals: (0, common_1.flattenExternals)(externals),
                piralInstances,
                entryFiles: appFile,
                logLevel,
                _: {},
            });
            return [dir, appPort];
        }
        return [(0, path_1.dirname)(appFile), appPort];
    })));
}
function checkSanity(pilets) {
    for (let i = 1; i < pilets.length; i++) {
        const previous = pilets[i - 1];
        const current = pilets[i];
        const previousInstances = previous.apps;
        const currentInstances = current.apps;
        const previousInstancesNames = previousInstances
            .map((m) => m.appPackage.name)
            .sort()
            .join(', ');
        const currentInstancesNames = currentInstances
            .map((m) => m.appPackage.name)
            .sort()
            .join(', ');
        const previousInstancesVersions = previousInstances.map((m) => m.appPackage.version).join(', ');
        const currentInstancesVersions = currentInstances.map((m) => m.appPackage.version).join(', ');
        if (previousInstancesNames !== currentInstancesNames) {
            return (0, common_1.log)('piletMultiDebugAppShellDifferent_0301', previousInstancesNames, currentInstancesNames);
        }
        else if (previousInstancesVersions !== currentInstancesVersions) {
            return (0, common_1.log)('piletMultiDebugAppShellVersions_0302', previousInstancesVersions, currentInstancesVersions);
        }
        else if (previous.externals.length !== current.externals.length) {
            return (0, common_1.log)('piletMultiDebugExternalsDifferent_0303', previous.externals, current.externals);
        }
        else if (previous.externals.some((m) => !current.externals.includes(m))) {
            return (0, common_1.log)('piletMultiDebugExternalsDifferent_0303', previous.externals, current.externals);
        }
    }
}
function debugPilet(baseDir = process.cwd(), options = {}) {
    var _a, _b;
    return __awaiter(this, void 0, void 0, function* () {
        const { entry = exports.debugPiletDefaults.entry, target = exports.debugPiletDefaults.target, open = exports.debugPiletDefaults.open, hmr = exports.debugPiletDefaults.hmr, port: originalPort = exports.debugPiletDefaults.port, publicUrl: originalPublicUrl = exports.debugPiletDefaults.publicUrl, logLevel = exports.debugPiletDefaults.logLevel, concurrency = exports.debugPiletDefaults.concurrency, krasrc: customkrasrc = exports.debugPiletDefaults.krasrc, optimizeModules = exports.debugPiletDefaults.optimizeModules, schemaVersion: originalSchemaVersion = exports.debugPiletDefaults.schemaVersion, _ = {}, hooks = {}, bundlerName, app, appInstanceDir, feed, } = options;
        const publicUrl = (0, common_1.normalizePublicUrl)(originalPublicUrl);
        const fullBase = (0, path_1.resolve)(process.cwd(), baseDir);
        (0, common_1.setLogLevel)(logLevel);
        yield ((_a = hooks.onBegin) === null || _a === void 0 ? void 0 : _a.call(hooks, { options, fullBase }));
        const watcherRef = yield (0, common_1.watcherTask)((watcherContext) => __awaiter(this, void 0, void 0, function* () {
            var _c, _d, _e, _f;
            (0, common_1.progress)('Reading configuration ...');
            const entryList = Array.isArray(entry) ? entry : [entry];
            const multi = entryList.length > 1 || entryList[0].indexOf('*') !== -1;
            (0, common_1.log)('generalDebug_0003', `Looking for (${multi ? 'multi' : 'single'}) "${entryList.join('", "')}" in "${fullBase}".`);
            const allEntries = yield (0, common_1.matchAnyPilet)(fullBase, entryList);
            const maxListeners = Math.max(2 + allEntries.length * 2, 16);
            (0, common_1.log)('generalDebug_0003', `Found the following entries: ${allEntries.join(', ')}`);
            if (allEntries.length === 0) {
                (0, common_1.fail)('entryFileMissing_0077');
            }
            (_c = process.stderr) === null || _c === void 0 ? void 0 : _c.setMaxListeners(maxListeners);
            (_d = process.stdout) === null || _d === void 0 ? void 0 : _d.setMaxListeners(maxListeners);
            (_e = process.stdin) === null || _e === void 0 ? void 0 : _e.setMaxListeners(maxListeners);
            const pilets = yield (0, common_1.concurrentWorkers)(allEntries, concurrency, (entryModule) => __awaiter(this, void 0, void 0, function* () {
                var _g;
                const targetDir = (0, path_1.dirname)(entryModule);
                const { peerDependencies, peerModules, root, apps, ignored, importmap, schema } = yield (0, common_1.retrievePiletData)(targetDir, app);
                const schemaVersion = originalSchemaVersion || schema || common_1.config.schemaVersion || 'v2';
                const piralInstances = apps.map((m) => m.appPackage.name);
                const externals = (0, common_1.combinePiletExternals)(piralInstances, peerDependencies, peerModules, importmap);
                const mocks = (0, path_1.join)(targetDir, 'mocks');
                const dest = (0, path_1.resolve)(root, target);
                const outDir = (0, path_1.dirname)(dest);
                const outFile = (0, path_1.basename)(dest);
                const mocksExists = yield (0, common_1.checkExistingDirectory)(mocks);
                (0, common_1.validateSharedDependencies)(importmap);
                yield ((_g = hooks.beforeBuild) === null || _g === void 0 ? void 0 : _g.call(hooks, { root, publicUrl, importmap, entryModule, schemaVersion }));
                watcherContext.watch((0, path_1.join)(root, 'package.json'));
                watcherContext.watch((0, path_1.join)(root, 'pilet.json'));
                const bundler = yield (0, bundler_1.callPiletDebug)({
                    root,
                    piralInstances,
                    optimizeModules,
                    hmr,
                    externals,
                    targetDir,
                    importmap,
                    outFile,
                    outDir,
                    entryModule: `./${(0, path_1.relative)(root, entryModule)}`,
                    logLevel,
                    version: schemaVersion,
                    ignored,
                    _,
                }, bundlerName);
                bundler.on((args) => {
                    var _a;
                    (_a = hooks.afterBuild) === null || _a === void 0 ? void 0 : _a.call(hooks, Object.assign(Object.assign({}, args), { root,
                        publicUrl,
                        importmap,
                        entryModule,
                        schemaVersion,
                        bundler,
                        outFile,
                        outDir }));
                });
                return {
                    apps,
                    publicUrl,
                    externals,
                    bundler,
                    mocks: mocksExists ? mocks : undefined,
                    root,
                };
            }));
            // sanity check see #250
            checkSanity(pilets);
            yield ((_f = hooks.beforeApp) === null || _f === void 0 ? void 0 : _f.call(hooks, { appInstanceDir, pilets }));
            const appInstances = appInstanceDir
                ? [[appInstanceDir, 0]]
                : yield getOrMakeApps(pilets[0], logLevel);
            Promise.all(pilets.map((p) => p.bundler.ready())).then(() => (0, common_1.logDone)(`Ready!`));
            pilets.forEach((p) => p.bundler.start());
            yield Promise.all(appInstances.sort(byPort).map(([appDir, appPort], i) => __awaiter(this, void 0, void 0, function* () {
                var _h;
                const appRoot = (0, path_1.dirname)(yield (0, common_1.findFile)(appDir, 'package.json'));
                const platform = (0, common_1.configurePlatform)();
                yield ((_h = hooks.afterApp) === null || _h === void 0 ? void 0 : _h.call(hooks, { appInstanceDir, pilets }));
                const suggestedPort = appPort || originalPort + i;
                yield platform.startModule({
                    appRoot,
                    appDir,
                    pilets,
                    customkrasrc,
                    feed,
                    fullBase,
                    hooks,
                    open,
                    originalPort: suggestedPort,
                    publicUrl,
                    maxListeners,
                    registerEnd(cb) {
                        return watcherContext.onClean(cb);
                    },
                    registerWatcher(file) {
                        return watcherContext.watch(file);
                    }
                });
            })));
        }));
        yield Promise.all([watcherRef.end]);
        yield ((_b = hooks.onEnd) === null || _b === void 0 ? void 0 : _b.call(hooks, {}));
    });
}
exports.debugPilet = debugPilet;
//# sourceMappingURL=debug-pilet.js.map