"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.debugPiral = exports.debugPiralDefaults = void 0;
const path_1 = require("path");
const bundler_1 = require("../bundler");
const types_1 = require("../types");
const common_1 = require("../common");
exports.debugPiralDefaults = {
    entry: './',
    target: './dist',
    port: common_1.config.port,
    publicUrl: '/',
    logLevel: types_1.LogLevels.info,
    open: common_1.config.openBrowser,
    hmr: true,
    krasrc: undefined,
    optimizeModules: false,
};
function debugPiral(baseDir = process.cwd(), options = {}) {
    var _a, _b;
    return __awaiter(this, void 0, void 0, function* () {
        const { entry = exports.debugPiralDefaults.entry, target = exports.debugPiralDefaults.target, open = exports.debugPiralDefaults.open, hmr = exports.debugPiralDefaults.hmr, port: originalPort = exports.debugPiralDefaults.port, publicUrl: originalPublicUrl = exports.debugPiralDefaults.publicUrl, logLevel = exports.debugPiralDefaults.logLevel, krasrc: customkrasrc = exports.debugPiralDefaults.krasrc, optimizeModules = exports.debugPiralDefaults.optimizeModules, feed, _ = {}, hooks = {}, bundlerName, } = options;
        const publicUrl = (0, common_1.normalizePublicUrl)(originalPublicUrl);
        const fullBase = (0, path_1.resolve)(process.cwd(), baseDir);
        (0, common_1.setLogLevel)(logLevel);
        yield ((_a = hooks.onBegin) === null || _a === void 0 ? void 0 : _a.call(hooks, { options, fullBase }));
        (0, common_1.progress)('Reading configuration ...');
        const buildRef = yield (0, common_1.watcherTask)((watcherContext) => __awaiter(this, void 0, void 0, function* () {
            var _c;
            const entryFiles = yield (0, common_1.retrievePiralRoot)(fullBase, entry);
            const { externals, name, root, ignored } = yield (0, common_1.retrievePiletsInfo)(entryFiles);
            const piralInstances = [name];
            const dest = (0, common_1.getDestination)(entryFiles, (0, path_1.resolve)(fullBase, target));
            yield (0, common_1.checkCliCompatibility)(root);
            (0, common_1.validateSharedDependencies)(externals);
            yield ((_c = hooks.beforeBuild) === null || _c === void 0 ? void 0 : _c.call(hooks, { root, publicUrl, externals, entryFiles, piralInstances }));
            watcherContext.watch((0, path_1.join)(root, 'package.json'));
            watcherContext.watch((0, path_1.join)(root, 'piral.json'));
            const bundler = yield (0, bundler_1.callPiralDebug)(Object.assign(Object.assign({ root,
                piralInstances,
                optimizeModules,
                hmr, externals: externals.map((m) => m.name), publicUrl,
                entryFiles,
                logLevel,
                ignored }, dest), { _ }), bundlerName);
            bundler.ready().then(() => (0, common_1.logDone)(`Ready!`));
            bundler.on((args) => {
                var _a;
                (_a = hooks.afterBuild) === null || _a === void 0 ? void 0 : _a.call(hooks, Object.assign(Object.assign(Object.assign({}, args), { root, publicUrl, externals, entryFiles, piralInstances, bundler }), dest));
            });
            bundler.start();
            return { bundler, entryFiles, root };
        }));
        const platform = (0, common_1.configurePlatform)();
        const serverRef = yield (0, common_1.watcherTask)((watcherContext) => __awaiter(this, void 0, void 0, function* () {
            watcherContext.dependOn(buildRef);
            const { bundler, entryFiles, root } = buildRef.data;
            const targetDir = (0, path_1.dirname)(entryFiles);
            yield platform.startShell({
                bundler,
                customkrasrc,
                feed,
                fullBase,
                hooks,
                open,
                originalPort,
                publicUrl,
                root,
                targetDir,
                registerEnd(cb) {
                    return watcherContext.onClean(cb);
                },
                registerWatcher(file) {
                    return watcherContext.watch(file);
                }
            });
        }));
        yield Promise.all([buildRef.end, serverRef.end]);
        yield ((_b = hooks.onEnd) === null || _b === void 0 ? void 0 : _b.call(hooks, {}));
    });
}
exports.debugPiral = debugPiral;
//# sourceMappingURL=debug-piral.js.map