"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.integrateDebugger = void 0;
const piral_debug_utils_1 = require("piral-debug-utils");
function integrateDebugger(context, options, debug = {}) {
    (0, piral_debug_utils_1.installPiralDebug)(Object.assign(Object.assign({}, debug), { addPilet: context.addPilet, removePilet: context.removePilet, updatePilet(pilet) {
            if (!pilet.disabled) {
                const { createApi } = options;
                const newApi = createApi(pilet);
                try {
                    context.injectPilet(pilet);
                    pilet.setup(newApi);
                }
                catch (error) {
                    console.error(error);
                }
            }
            else {
                context.injectPilet(pilet);
            }
        }, fireEvent: context.emit, getDependencies() {
            return Object.keys(options.dependencies);
        },
        getExtensions() {
            return context.readState((s) => Object.keys(s.registry.extensions));
        },
        getRoutes() {
            const registeredRoutes = context.readState((state) => Object.keys(state.registry.pages));
            const componentRoutes = context.readState((state) => Object.keys(state.routes));
            return [...componentRoutes, ...registeredRoutes];
        },
        getGlobalState() {
            return context.readState((s) => s);
        },
        navigate(path, state) {
            return context.navigation.push(path, state);
        },
        getPilets() {
            return context.readState((s) => s.modules);
        },
        integrate(dbg) {
            context.dispatch((s) => (Object.assign(Object.assign({}, s), { components: Object.assign(Object.assign({}, s.components), dbg.components), routes: Object.assign(Object.assign({}, s.routes), dbg.routes), registry: Object.assign(Object.assign({}, s.registry), { wrappers: Object.assign(Object.assign({}, s.registry.wrappers), dbg.wrappers) }) })));
            context.state.subscribe((current, previous) => {
                const pilets = current.modules !== previous.modules;
                const pages = current.registry.pages !== previous.registry.pages || current.routes !== previous.routes;
                const extensions = current.registry.extensions !== previous.registry.extensions;
                const state = current !== previous;
                dbg.onChange(previous, current, {
                    pilets,
                    pages,
                    extensions,
                    state,
                });
            });
        } }));
}
exports.integrateDebugger = integrateDebugger;
//# sourceMappingURL=debugger.js.map