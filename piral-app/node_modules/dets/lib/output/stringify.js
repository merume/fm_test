"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.stringifyNode = exports.stringifyReadonly = exports.stringifyPredicate = exports.stringifyGetAccessor = exports.stringifySetAccessor = exports.stringifyMember = exports.stringifyTernary = exports.stringifyTypeParameter = exports.stringifyTypeArgs = exports.stringifyTypes = exports.stringifyImplements = exports.stringifyExtends = exports.stringifyEnum = exports.stringifyClass = exports.stringifyInterface = exports.stringifyIndexedAccess = exports.stringifyMapped = exports.stringifyIndex = exports.stringifyConstructor = exports.stringifySignature = exports.stringifyParameters = exports.stringifyParameter = exports.stringifyProp = exports.stringifyTupleProp = exports.stringifyPropName = exports.stringifyComment = void 0;
const helpers_1 = require("../helpers");
function stringifyComment(type) {
    if (type.comment) {
        const lines = type.comment
            .split('\n')
            .map((line) => ` * ${line}\n`)
            .join('');
        return `/**\n${lines} */\n`;
    }
    return '';
}
exports.stringifyComment = stringifyComment;
function stringifyPropName(name) {
    return typeof name === 'string' ? (0, helpers_1.makeIdentifier)(name) : `[${stringifyNode(name)}]`;
}
exports.stringifyPropName = stringifyPropName;
function stringifyTupleProp(type) {
    const target = type.valueType;
    const comment = stringifyComment(type);
    const isOpt = type.optional ? '?' : '';
    const name = stringifyPropName(type.name);
    if (typeof target === 'undefined') {
        return `${comment}${name}${isOpt}: any`;
    }
    else if (target.kind === 'function') {
        return `${comment}${name}${isOpt}: ${stringifySignature(target, 0 /* StringifyMode.default */)}`;
    }
    else {
        return `${comment}${name}${isOpt}: ${stringifyNode(target)}`;
    }
}
exports.stringifyTupleProp = stringifyTupleProp;
function stringifyProp(type) {
    const target = type.valueType;
    const comment = stringifyComment(type);
    const isOpt = type.optional ? '?' : '';
    const modifier = type.modifiers ? `${type.modifiers} ` : '';
    const name = stringifyPropName(type.name);
    if (typeof target === 'undefined') {
        return `${comment}${modifier}${name}${isOpt}: any`;
    }
    else if (target.kind === 'function') {
        return `${comment}${modifier}${name}${isOpt}${stringifySignature(target, 1 /* StringifyMode.property */)}`;
    }
    else {
        return `${comment}${modifier}${name}${isOpt}: ${stringifyNode(target)}`;
    }
}
exports.stringifyProp = stringifyProp;
function stringifyParameter(param) {
    const isOpt = param.optional ? '?' : '';
    const spread = param.spread ? '...' : '';
    const modifiers = param.modifiers ? `${param.modifiers} ` : '';
    return `${modifiers}${spread}${param.param}${isOpt}: ${stringifyNode(param.value)}`;
}
exports.stringifyParameter = stringifyParameter;
function stringifyParameters(params) {
    return params.map(stringifyParameter).join(', ');
}
exports.stringifyParameters = stringifyParameters;
function stringifySignature(type, mode, anonymous = false) {
    const ctor = type.kind === 'new' ? 'new ' : '';
    const prop = (mode & 1 /* StringifyMode.property */) !== 0;
    const paren = (mode & 2 /* StringifyMode.parenthesis */) !== 0;
    const comment = anonymous ? stringifyComment(type) : '';
    const parameters = stringifyParameters(type.parameters);
    const ta = stringifyTypeArgs(type);
    const rt = stringifyNode(type.returnType);
    const del = prop ? ': ' : ' => ';
    const result = `${ctor}${ta}(${parameters})${del}${rt}`;
    const fn = paren ? `(${result})` : result;
    return `${comment}${fn}`;
}
exports.stringifySignature = stringifySignature;
function stringifyConstructor(type) {
    const parameters = stringifyParameters(type.parameters);
    return `constructor(${parameters})`;
}
exports.stringifyConstructor = stringifyConstructor;
function stringifyIndex(type) {
    const isOpt = type.optional ? '?' : '';
    const index = stringifyParameters(type.parameters);
    return `[${index}]${isOpt}: ${stringifyNode(type.valueType)}`;
}
exports.stringifyIndex = stringifyIndex;
function stringifyMapped(type) {
    const isOpt = type.optional ? '?' : '';
    const index = `${type.name} in ${stringifyNode(type.constraint)}`;
    return `[${index}]${isOpt}: ${stringifyNode(type.value)}`;
}
exports.stringifyMapped = stringifyMapped;
function stringifyIndexedAccess(type) {
    const front = stringifyNode(type.index);
    const back = stringifyNode(type.object);
    return `${back}[${front}]`;
}
exports.stringifyIndexedAccess = stringifyIndexedAccess;
function stringifyInterface(type) {
    const lines = type.props.map((p) => stringifyNode(p, 1 /* StringifyMode.property */));
    if (type.mapped) {
        lines.push(stringifyMapped(type.mapped));
    }
    return (0, helpers_1.toBlock)(lines, ';');
}
exports.stringifyInterface = stringifyInterface;
function stringifyClass(type) {
    const lines = type.props.map((p) => stringifyNode(p));
    return (0, helpers_1.toBlock)(lines, ';');
}
exports.stringifyClass = stringifyClass;
function stringifyEnum(values) {
    const lines = values.map((p) => stringifyNode(p));
    return (0, helpers_1.toBlock)(lines, ',');
}
exports.stringifyEnum = stringifyEnum;
function stringifyExtends(type) {
    const { extends: es } = type;
    return es.length ? ` extends ${es.map((t) => stringifyNode(t)).join(', ')}` : '';
}
exports.stringifyExtends = stringifyExtends;
function stringifyImplements(type) {
    const { implements: is } = type;
    return is.length ? ` implements ${is.map((t) => stringifyNode(t)).join(', ')}` : '';
}
exports.stringifyImplements = stringifyImplements;
function stringifyTypes(types) {
    return types.map((t) => stringifyNode(t)).join(', ');
}
exports.stringifyTypes = stringifyTypes;
function stringifyTypeArgs(type) {
    var _a;
    if (((_a = type.types) === null || _a === void 0 ? void 0 : _a.length) > 0) {
        return `<${stringifyTypes(type.types)}>`;
    }
    return '';
}
exports.stringifyTypeArgs = stringifyTypeArgs;
function stringifyTypeParameter(type) {
    const name = stringifyNode(type.parameter);
    const constraint = stringifyNode(type.constraint);
    const defaults = stringifyNode(type.default);
    const constraintClause = constraint ? ` extends ${constraint}` : '';
    const defaultsClause = defaults ? ` = ${defaults}` : '';
    return `${name}${constraintClause}${defaultsClause}`;
}
exports.stringifyTypeParameter = stringifyTypeParameter;
function stringifyTernary(condition) {
    const t = stringifyNode(condition.check);
    const e = stringifyNode(condition.extends);
    const p = stringifyNode(condition.primary);
    const a = stringifyNode(condition.alternate);
    return `${t} extends ${e} ? ${p} : ${a}`;
}
exports.stringifyTernary = stringifyTernary;
function stringifyMember(member) {
    const name = `${stringifyComment(member)}${member.name}`;
    if (member.value) {
        return `${name} = ${stringifyNode(member.value)}`;
    }
    return name;
}
exports.stringifyMember = stringifyMember;
function stringifySetAccessor(accessor) {
    const comment = stringifyComment(accessor);
    const modifier = accessor.modifiers ? `${accessor.modifiers} ` : '';
    const args = stringifyParameters(accessor.parameters);
    return `${comment}${modifier}set ${accessor.name}(${args})`;
}
exports.stringifySetAccessor = stringifySetAccessor;
function stringifyGetAccessor(accessor) {
    const comment = stringifyComment(accessor);
    const modifier = accessor.modifiers ? `${accessor.modifiers} ` : '';
    const result = stringifyNode(accessor.type);
    return `${comment}${modifier}get ${accessor.name}(): ${result}`;
}
exports.stringifyGetAccessor = stringifyGetAccessor;
function stringifyPredicate(predicate) {
    const type = stringifyNode(predicate.value);
    return `${predicate.name} is ${type}`;
}
exports.stringifyPredicate = stringifyPredicate;
function stringifyReadonly(type) {
    const value = type.value;
    if (value.kind === 'ref' && value.refName === 'Array' && value.types.length === 1) {
        const [arg] = value.types;
        return `readonly ${stringifyNode(arg)}[]`;
    }
    return `readonly ${stringifyNode(value)}`;
}
exports.stringifyReadonly = stringifyReadonly;
function stringifyNode(type, mode = 0 /* StringifyMode.default */) {
    switch (type === null || type === void 0 ? void 0 : type.kind) {
        case 'interface':
            return stringifyInterface(type);
        case 'prop':
            return stringifyProp(type);
        case 'tuple-prop':
            return stringifyTupleProp(type);
        case 'ref':
            return `${type.refName}${stringifyTypeArgs(type)}`;
        case 'typeParameter':
            return stringifyTypeParameter(type);
        case 'union':
            return type.types.map((u) => stringifyNode(u, 2 /* StringifyMode.parenthesis */)).join(' | ');
        case 'intersection':
            return type.types.map((u) => stringifyNode(u)).join(' & ');
        case 'member':
            return stringifyMember(type);
        case 'conditional':
            return stringifyTernary(type);
        case 'readonly':
            return stringifyReadonly(type);
        case 'unique':
            return `unique ${stringifyNode(type.value)}`;
        case 'keyof':
            return `keyof ${stringifyNode(type.value)}`;
        case 'infer':
            return `infer ${stringifyNode(type.parameter)}`;
        case 'any':
        case 'null':
        case 'void':
        case 'undefined':
        case 'boolean':
        case 'unknown':
        case 'bigint':
        case 'number':
        case 'never':
        case 'string':
            return type.kind;
        case 'nonPrimitive':
            return type.name || 'object';
        case 'esSymbol':
            return 'symbol';
        case 'unidentified':
            return 'any';
        case 'literal':
            return `${type.value}`;
        case 'indexedAccess':
            return stringifyIndexedAccess(type);
        case 'index':
            return stringifyIndex(type);
        case 'class':
            return `class ${stringifyClass(type)}`;
        case 'constructor':
            return stringifyConstructor(type);
        case 'mapped':
            return stringifyMapped(type);
        case 'substitution':
            return stringifyNode(type.variable);
        case 'rest':
            return `...${stringifyNode(type.value)}`;
        case 'new':
        case 'function':
            return stringifySignature(type, mode, true);
        case 'tuple':
            return `[${stringifyTypes(type.types)}]`;
        case 'set':
            return stringifySetAccessor(type);
        case 'get':
            return stringifyGetAccessor(type);
        case 'predicate':
            return stringifyPredicate(type);
        case 'template':
            return `\`${type.parts.map((p) => (typeof p === 'string' ? p : `\${${stringifyNode(p)}}`)).join('')}\``;
        case 'parenthesis':
            return `(${stringifyNode(type.value)})`;
    }
    return '';
}
exports.stringifyNode = stringifyNode;
