"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.includeProp = exports.includeClauses = void 0;
const ts = require("typescript");
const helpers_1 = require("../helpers");
function isText(actual, expected) {
    if (typeof actual === 'string') {
        return actual === expected;
    }
    else if (Array.isArray(actual)) {
        return actual.some((m) => m.text === expected);
    }
    return false;
}
function includeClauses(context, clauses, newClause, tags = []) {
    var _a;
    const types = [];
    for (const clause of newClause.types) {
        const decl = (0, helpers_1.getDeclarationFromNode)(context.checker, clause.expression);
        const name = (_a = decl === null || decl === void 0 ? void 0 : decl.symbol) === null || _a === void 0 ? void 0 : _a.name;
        // check if we should remove the clause
        if (decl && !tags.some((m) => m.name === 'dets_removeclause' && isText(m.text, name))) {
            types.push(clause);
        }
    }
    clauses.push(Object.assign(Object.assign({}, newClause), { types: ts.factory.createNodeArray(types) }));
}
exports.includeClauses = includeClauses;
function includeProp(props, newProp, getPropName, tags = []) {
    const name = getPropName(newProp.name);
    // check if we should remove the prop
    if (tags.some((m) => m.name === 'dets_removeprop' && isText(m.text, name))) {
        return;
    }
    for (const oldProp of props) {
        if (oldProp.kind === newProp.kind && getPropName(oldProp.name) === name) {
            if (!ts.isMethodSignature(newProp) && !ts.isCallSignatureDeclaration(newProp)) {
                return;
            }
        }
    }
    props.push(newProp);
}
exports.includeProp = includeProp;
